## Pain point - 왜 이런짓을?

- 기본적으로 [Kubeadm](https://kubernetes.io/docs/reference/setup-tools/kubeadm) 은 CA 인증서는 10년, CA-signed 인증서는 1년 뒤에 만료되도록 설정하여 인증서를 발급한다.
- 그 이유는
	- 주기적으로 인증서를 재발급하도록 하여 보안 강화
		- CA-Signed 인증서 만료기간을 1년 이상으로 하는 것은 Security Issue 를 야기할 수 있다고 [여기](https://github.com/kubernetes/kubeadm/issues/1505#issuecomment-482798539) 에서 그랬다
	- 주기적으로 클러스터 버전을 업그레이드 하도록 유도
		- Kubeadm 은 클러스터 버전 업그레이드 시에 인증서도 재발급하는 정책으로 [클러스터 관리자들이 주기적으로 버전을 업그레이드 하여 클러스터 버전을 최신으로 유지시키고 동시에 보안성도 강화](https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#automatic-certificate-renewal) 하도록 유도하더라
- 하지만 이것은 폐쇄망 환경일 때 오히려 방해가 되기도 한다.
	- 높은 보안 수준을 위해 폐쇄망으로 클러스터를 구축했기에 오히려 인증서 재발급을 통한 보안 강화는 굳이? 의 느낌이 강하다.
	- 폐쇄망 환경을 요구하는 보안이 중요한 곳에서는 소프트웨어 보안 심사 등을 버전마다 받는 것이 힘들기 때문에 그냥 한 버전으로 고정시켜 놓기도 한다.
		- 또한 폐쇄망에서 클러스터 버전을 업그레이드 하는 것은 생각보다 고되다. `.deb` 등의 패키지 파일, 컨테이너 이미지 파일 등을 전부 다운받아 폐쇄망 환경으로 갖고 들어가 작업해야 하기 때문
- 따라서 나는 이 클러스터를 적어도 내가 살아 있는 한 인증서가 만료되지 않게 하려고 한다

## Step 1. Kubeadm 인증서 분석

- 쿠버네티스 Control plane 이 사용하는 인증서에 대한 것은 [[Kubernetes Control plane TLS Explained - Kubeadm 이 생성해주는 인증서 톺아보기]]를 확인하자
- 요약하면 클러스터가 생성될 때 `ca`, `etcd-ca`, `front-proxy-ca` 가 생성되고 이것들을 이용해 각 Control plane 구성요소들이 사용할 인증서들이 생성되게 된다.
- 따라서 기간을 임의로 바꿀 때에도 동일한 순서로 가면 된다
	- 즉, `ca`, `etcd-ca`, `front-proxy-ca` 를 먼저 생성한 후에, 이것들을 이용해 각 Control plane 구성요소들이 사용할 인증서를 생성하면 된다

## Step 2. CA 인증서 생성하기

- 솔직히 CA 인증서 생성하는 것은 Configuration file 만 있으면 명령어 한줄로 끝난다

### `ca` 인증서 생성하기

#### TL;DR!

- `ca.cnf` 파일

```
[req]
distinguished_name = cert_dn
x509_extensions = v3_req
prompt = no

[cert_dn]
CN = kubernetes

[v3_req]
keyUsage = critical, digitalSignature, keyEncipherment, keyCertSign
basicConstraints = critical, CA:TRUE
subjectKeyIdentifier = hash
subjectAltName = @alt_names

[alt_names]
DNS.0 = kubernetes
```

- `ca.cnf` 로 200년짜리 (`73000`) 인증서 생성

```bash
openssl req -x509 -new -nodes -newkey rsa:2048 -keyout ca.key -out ca.crt -config ca.cnf -days 73000 -set_serial 0
```

#### 그래도 왜 이래 되는지 한번 보고 가야겠지?

- 일단 `ca` 인증서를 openssl 로 한번 확인해보자

```bash
openssl x509 -in /etc/kubernetes/pki/ca.crt -text -noout
```

### `etcd-ca` 인증서 생성하기

- `ca` 인증서 생성할때처럼 추적해보면 아래와 같은 TL;DR 이 될 거시여

#### TL;DR

- `etcd-ca.cnf` 파일

```
[req]
distinguished_name = cert_dn
x509_extensions = v3_req
prompt = no

[cert_dn]
CN = etcd-ca

[v3_req]
keyUsage = critical, digitalSignature, keyEncipherment, keyCertSign
basicConstraints = critical, CA:TRUE
subjectKeyIdentifier = hash
subjectAltName = @alt_names

[alt_names]
DNS.0 = etcd-ca
```

- `etcd-ca.cnf` 로 200년짜리 (`73000`) 인증서 생성

```bash
openssl req -x509 -new -nodes -newkey rsa:2048 -keyout etcd-ca.key -out etcd-ca.crt -config etcd-ca.cnf -days 73000 -set_serial 0
```

### `front-proxy-ca` 인증서 생성하기

- 마찬가지로,

#### TL;DR

- `front-proxy-ca.cnf` 파일

```
[req]
distinguished_name = cert_dn
x509_extensions = v3_req
prompt = no

[cert_dn]
CN = front-proxy-ca

[v3_req]
keyUsage = critical, digitalSignature, keyEncipherment, keyCertSign
basicConstraints = critical, CA:TRUE
subjectKeyIdentifier = hash
subjectAltName = @alt_names

[alt_names]
DNS.0 = front-proxy-ca
```

- `front-proxy-ca.cnf` 로 200년짜리 (`73000`) 인증서 생성

```bash
openssl req -x509 -new -nodes -newkey rsa:2048 -keyout front-proxy-ca.key -out front-proxy-ca.crt -config front-proxy-ca.cnf -days 73000 -set_serial 0
```

- 여기까지 하면 필요한 CA 인증서들이 모두 생성된다...

## Step 3. CA-Signed 인증서 생성하기

- CA-Signed 인증서를 위와 같은 방법으로 `openssl` 을 이용해 분석해서 생성할 수도 있지만, 파일 갯수가 많아도 너무 많아서 귀찮다.
- 그래서 Kubeadm 코드를 변경하고 직접 빌드해서 원큐에 해결하는 방법을 사용해 보자.