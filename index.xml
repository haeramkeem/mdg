<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>Madison Digital Garden</title>
      <link>https://mdg.haeramk.im</link>
      <description>Last 10 notes on Madison Digital Garden</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>(충남대) 컴퓨터 네트워크 강의록</title>
    <link>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/(%EC%B6%A9%EB%82%A8%EB%8C%80)-%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B0%95%EC%9D%98%EB%A1%9D</link>
    <guid>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/(%EC%B6%A9%EB%82%A8%EB%8C%80)-%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B0%95%EC%9D%98%EB%A1%9D</guid>
    <description>개요 § 강의 정보 § 강의 구분소속교수시기학부 수업충남대학교 공과대학 컴퓨터공학과김상하 교수님2021년 가을학기 실습 자료 § ARP 프로토콜 구현: github://haeramkeem/Fall2021-CNU-Comnet-ARP Static router 구현: github://haeramkeem/Fall2021-CNU-Comnet-Router 목차 § 01.</description>
    <pubDate>Sun, 05 Nov 2023 09:55:00 GMT</pubDate>
  </item><item>
    <title>01. 데이터통신 회고</title>
    <link>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/01.-%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%86%B5%EC%8B%A0-%ED%9A%8C%EA%B3%A0</link>
    <guid>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/01.-%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%86%B5%EC%8B%A0-%ED%9A%8C%EA%B3%A0</guid>
    <description> 충남대학교 컴퓨터공학과 김상하 교수님의 &quot;컴퓨터 네트워크&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 구어적 표현 이 포함되어 있을 수 있습니다. 지난학기 복습 § Physical Layer : Bit transmission - 0과 1을 전송하는 데 전압의 높음과 낮음으로만 0과 1을 표현하는 것에 많은 단점이 있어 Encoding과 Modulation의 방법으로 bit을 전환해 전송하는 것 Data link Layer : Frame transmission - 노드 - 노드 간 통신에서 에러가 전혀 없는 통신을 하기 위한 절차와 에러를 잡아낼 수 있는 별도의 비트를 묶어 데이터를 프레임화 시키는 것을 담당함 또한 MAC주소로 알려진 고유한 물리주소를 사용해 송신지와 수신지의 주소를 표시함.</description>
    <pubDate>Sun, 05 Nov 2023 09:55:00 GMT</pubDate>
  </item><item>
    <title>02. Network Layer</title>
    <link>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/02.-Network-Layer</link>
    <guid>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/02.-Network-Layer</guid>
    <description> 충남대학교 컴퓨터공학과 김상하 교수님의 &quot;컴퓨터 네트워크&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 구어적 표현 이 포함되어 있을 수 있습니다. IP § 일단 IP는 Network Layer의 한 종류인데 이것 말고도 다른 것들도 있었지만 결과적으로 IP가 승리를 거두었고 앞으로도 계속 쓰이게 될 것이다 Network Layer로 IP를 사용하는 통신망에 연결되어 있으면 인터넷에 연결되어 있다고 하더라 그리고 컴퓨터같은 송수신지 말고 중간에 거쳐가는 Intermediate Node같은 경우에는 Network Layer까지만 있고 그 상위 프로토콜에 대한 기능은 가지고 있지 않더라 - 까지도 데통시간에 배웠쥬? Packet Switching § 뭐 옛날에는 Circuit switching이라는 기술도 있었지만 지금은 거의 안쓴댄다 Principles of Packet Switching § 일단 송신하려고 하는 user data를 패킷단위로 쪼개고 각 패킷에 packet header라는 control information을 붙인다.</description>
    <pubDate>Sun, 05 Nov 2023 09:55:00 GMT</pubDate>
  </item><item>
    <title>03. Packet switching example</title>
    <link>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/03.-Packet-switching-example</link>
    <guid>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/03.-Packet-switching-example</guid>
    <description> 충남대학교 컴퓨터공학과 김상하 교수님의 &quot;컴퓨터 네트워크&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 구어적 표현 이 포함되어 있을 수 있습니다. 참고 § Datagram방식은 미 국방성에서 나온 아이디어이다 전장의 특성상 네트워크가 끊어질 가능성이 높기 때문에, 네트워크가 끊어지더라고 우회해서 패킷을 보내기 위해 만들어진 기술인 것 Virtual circuit의 경우에는 경로가 설정되고 나면 그 방향으로만 보낼 수 있기 때문에, 중간에 끊기면 패킷을 보낼 수가 없는 반면 Datagram의 경우에는 다른 경로로 갈 수 있기 때문에 패킷이 도착할 수 있는 가능성이 더 높아지게 된다 Packet switching example § 간단한 코드를 통해 작동방법 이해하기 Datagram § 일단 기본 자료 구조는 위와 같더라 위의 자료구조는 Datagram의 자료구조인데 Virtual circuit의 자료구조도 packet_type만 바뀌고 frame_type은 바뀌지 않는다 즉, Network layer가 바뀌어도 다른 계층은 바꾸지 않아도 된다는 것을 이것을 통해서도 알 수 있다 그리고 위의 코드도 Datagram과 Virtual circuit이 저 send_data()라는 함수만 변경되고 나머지는 다 똑같이 이루어지더라 즉, Datagram을 위한 함수와 Virtual circuit을 위한 함수가 따로 제공되고 상위계층에서는 목적에 맞게 해당 함수를 불러다 쓰기만 하면 되고 내부 동작을 알 필요는 없으며 Data Link Layer의 send_data()함수는 변경하지 않아도 된다는 것 또한 Sender나 reciever의 경우에는 main()함수에 Application layer와 Transport layer가 들어갔지만 위 그림처럼 Node의 경우에는 main()함수에 Network layer가 들어간다 - Node의 최상위 노드는 Network layer이기 때문 Virtual circuit § 구조를 보면 일단 위와 같다 - 이건 실제 패킷의 구조가 아닌 이해를 위해 간략하게 표시한 구조임 위에서 보여준 Datagram의 패킷과는 다르게 Virtual circuit패킷에는 connection과 disconnection phase를 나타내기 위한 비트와 별도의 패킷 구조가 존재한다 vc_num : Virtual circuit number.</description>
    <pubDate>Sun, 05 Nov 2023 09:55:00 GMT</pubDate>
  </item><item>
    <title>04. Routing 복습</title>
    <link>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/04.-Routing-%EB%B3%B5%EC%8A%B5</link>
    <guid>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/04.-Routing-%EB%B3%B5%EC%8A%B5</guid>
    <description> 충남대학교 컴퓨터공학과 김상하 교수님의 &quot;컴퓨터 네트워크&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 구어적 표현 이 포함되어 있을 수 있습니다. TCP/IP § OSI 7계층과 대비되는 TCP/IP계층의 전체적인 구조는 다음과 같다 네트워크 계층에서는 IP가 사용되고 나머지 ICMP, IGMP, RARP, ARP는 IP를 보조하는 역할을 하게 되며 Transport에는 STCP, TCP, UDP가 있지만 TCP가 주로 쓰인다 Internet Protocol의 약자가 IP이고 Transmission Control Protocol의 약자가 TCP이다 Internet Routing § 데통시간 배운 Routing에 대해서 복습하고 넘어가자고 일단 Routing이라는 것은 수신지의 주소를 이용해 어디로 가야할 지 길을 설정해주는 것인것 기억나제 그래서 길을 찾아주기 위해 주소를 key로 하고 나가야 될 port를 value로 하는 테이블을 가지고 있어야 되는데 이세상 모든 컴퓨터들의 주소와 그에 맞는 port를 매칭시켜 테이블을 만드는 것은 테이블의 사이즈도 커지고 찾는데도 오래걸릴것이여 따라서 아래의 그림처럼 주소 전체를 key로 하지 않고 주소의 앞 일부분(netid)만 key로 하고 그에 맞는 port를 value로 하되 해당 port로 나가서 접근할 수 있는 컴퓨터는 전부 해당 netid에 속하게 구성하게 된다 그렇게 하면 테이블의 사이즈도 작아지고 더 빨리 찾을 수 있기 때문 위의 그림에서 보면 netid를 key로 하고 port를 value로 해서 테이블을 구성한 뒤, port로 나갔을때의 호스트 그룹은 전부 같은 netid를 갖고 있는 것을 볼 수 있다 그래서 실제로의 IP주소를 보면 위처럼 A, B, C클래스로 나뉘어져 있다 일단 어느 클래스에 속하는 주소인지는 맨 처음의 몇개의 비트를 이용해 식별하게 된다 그리고 위 그림에 보면 netid랑 hostid가 있는데 netid는 위에서 설명한 것처럼 그루핑을 위한 것이고 이것은 인터넷을 관리하는 기관(Network Information Center)에서 특정 기관(뭐 예를들면 충남대)으로 발급해 주는 값이다 그리고 hostid는 netid를 받급받은 기관이 자신이 관리하는 호스트들에다가 나눠주는 값이 되는 거임 그래서 만약 큰 기관의 경우에는 NIC에서 A클래스 netid를 발급해주고, 작은 기관에는 C클래스 여러개를 발급해준다던지 그런식으로 사용하게 된다 Routing의 과정 § 일단 들어온 패킷의 Dst Addr를 봐야것제 그리고 Router가 가지고 있는 Routing Table(Forwarding Table) 와 Dst Addr를 비교해서 나가야 될 port번호를 알아내게 되는 방식이다 그리고 Routing Table은 다른 netid와 통신하는 외부망과의 연결을 위한 routing을 할때(그냥 일반적인 Router)는 netid를 가지고 port를 결정하도록 구성되어 있고 동일한netid를 가지는 내부망으로 들어왔을 때에는 주소 전체를 가지고 port번호를 결정하도록 구성 - 얘는 Gateway Router라는 놈이 담당하게 됨 Subnetting § 봐봐라 위처럼 198.</description>
    <pubDate>Sun, 05 Nov 2023 09:55:00 GMT</pubDate>
  </item><item>
    <title>05. Routing 예시</title>
    <link>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/05.-Routing-%EC%98%88%EC%8B%9C</link>
    <guid>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/05.-Routing-%EC%98%88%EC%8B%9C</guid>
    <description> 충남대학교 컴퓨터공학과 김상하 교수님의 &quot;컴퓨터 네트워크&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 구어적 표현 이 포함되어 있을 수 있습니다. Routing 의 과정 예시 § 기본 구조와 설정 § 일단 위와 같은 구조로 되어있고 내 컴퓨터에는 이렇게 설정이 되어있다고 해보자 그럼 위와 같은 테이블이 생성이 된다 - 위의 테이블은 내 컴퓨터의 routing table이다 일단 내가 IP주소는 168.</description>
    <pubDate>Sun, 05 Nov 2023 09:55:00 GMT</pubDate>
  </item><item>
    <title>06. IPv4, IPv6</title>
    <link>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/06.-IPv4,-IPv6</link>
    <guid>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/06.-IPv4,-IPv6</guid>
    <description> 충남대학교 컴퓨터공학과 김상하 교수님의 &quot;컴퓨터 네트워크&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 구어적 표현 이 포함되어 있을 수 있습니다. IP의 버전들 § v4가 나온 이후 v5와 v6가 나왔지만 v5의 경우에는 OSI 7 Layer를 도입한 실험적인 모델이었고 v6의 경우에는 v4에 밀려 잘 사용되지 않는댄다 Network layer 작동과정 다른 예시 § 위의 예시에서 주의해야 할 점은 Processing다음에 이어지는 패킷 구조에서 분홍색 박스이다 위의 그림은 조금 잘못되어있는데, Network layer에서는 IP header에 해당하는 앞부분의 회색 헤더만 붙이게 되고, Router table을 이용해 알아낸 어느 Interface (Network card)로 나가야되는지의 정보는 뒤에 footer로 붙이는 것이 아닌, datalink layer한테 함수의 argument로 전달해주게 된다 위의 그림은 host가 아닌 router의 작동원리에 대해 나타내는 것인데 일단 Router의 경우에는 main()함수가 Network layer이기 때문에 상위계층이 더 없다 그리고 마찬가지로 interface에 해당하는 저 분홍색 부분은 packet에 붙어서 하위 계층으로 전달되는 것이 아닌 argument의 형태로 전달된다 또한 하위계층에서 상위계층을 function call하는 것이 아닌 상위계층에서 하위계층을 function call하고, packet은 return statement를 통해 상위계층으로 전달된다는 것 주의하덤둥 Datagram § 이전에 배웠다시피 IP의 경우에는 Datagram방식으로 packet switching을 한다 이건 왜냐하면 Internet의 경우에는 전 세계에 걸쳐 연결되어 있는데 packet이 지나가는 network의 환경이 일정하지 않을 수 있기 때문에(이것을 Heterogeneous network라고 한다) Connection을 만드는 것은 불가능하기 때문 IPv4 § TCP / IP protocol suite 가 인터넷인 거고 이걸 위한 패킷 전송 메커니즘이 IPv4인 것 IPv4의 대표적인 특징은 다음과 같음 Connectionless datagram protocol : 뭐 datagram방식을 이용한다는 소리고 Unreliable, best-effort delivery service : 얘는 송신과정에서 에러가 날 수 있으나 최선을 다해 목적지까지 보내겠다는 뜻이다 즉, 에러의 여부는 중요하지 않고 목적지까지 도달하는게 목적인 셈 에러가 났을 경우 처리는 TCP에서 한다 IPv4 datagram format § VER은 말그대로 IP버전을 말하는 것 - IPv4의 경우에는 4가 들어간다 HLEN은 header length로, 4byte단위로 표현한다 - 위의 그림에서 한줄이 4byte이므로 저 한 줄이 몇개나 들어가있냐를 말하는 셈 보통 물리계층에서 4byte단위로 전송이 이루어지기 때문에 4byte단위로 표현함 그리고 중요한 것은 HLEN의 값은 무조건 5보다 커야 한다 - 즉, 헤더 길이가 20byte보다는 무조건 커야된다는 소리 - 이것보다 작은 경우에는 잘못된 것으로 판단하고 discard한다 이건 왜냐하면 위 그림에서 흰색으로 표현된 5개의 층은 무조건 있어야 되고 여기에 추가적으로 Option이 들어갈 수 있기 때문 만일 여기의 값이 8이어서 총 헤더의 길이가 32바이트가 된다면, 20바이트는 헤더에 꼭 필요하므로 나머지 12바이트가 Option의 길이가 되는 것이다 Total Length는 헤더를 포함한 패킷 하나의 전체 길이를 나타냄 여기에 들어가는 값은 당연히 1바이트 단위이다 - 40이면 40바이트가 총 패킷의 길이가 되는 셈 HLEN이란 Total length로 패킷 구조 도출해내는거 문제 나올거같다 Protocol은 아래의 그림에서의 프로토콜을 나타냄 즉, 상위계층의 프로토콜 중에서 어떤 프로토콜로 전송되었나를 나타내는 필드인 것 딴건몰라도 6이 TCP인것 정도는 알고있으라 ID, Flag, Fragmentation offset의 경우에는 fragmentation을 위한 필드인데 이것의 원리에 대해서는 설명하지 않고 fragmentation이 필요한 이유에 대해서만 좀 알고있으라 fragmentation이 필요한 이유는 Datalink에서 회선의 종류에 따라 한번에 보낼 수 있는 데이터의 양이 정해지기 때문 만일 광섬유같은 신뢰성이 높은 회선이라면, 에러가 잘 나지 않기 때문에 많은 양의 데이터를 한번에 보낼 수 있지만, 신뢰성이 낮은 회선의 경우에는 적은 양의 데이터를 보내야 한다 - 왜냐하면 에러가 많이 나는 회선에서 많은 데이터를 보내게 되면 에러가 났을 경우 그 많은 데이터를 다시 보내야 하고, 결과적으로 많은 오버헤드가 발생하게 됨 따라서 회선에 따라 한번에 보낼 수 있는 데이터의 양이 정해지고, 만일 한번에 보낼 수 있는 데이터보다 더 많은 데이터가 들어오면 이것을 특정 크기로 잘라 여러번 송신하게 되는 것 실습시간에 MTU(Maximum Transfer Unit) 으로 1500을 설정한 것이 이러한 이유에서다 - Ethernet의 경우에는 1500byte가 MTU이고, 따라서 이것보다 더 큰 데이터가 들어오면 해당 크기로 잘라 여러번 보내게 되는 것 그리고 라우터에서 단편화된 패킷을 받으면 이것들을 전부 합친 다음 송신 회선의 MTU에 따라 새롭게 단편해 전송하게 된다 - 패킷을 잘라 송신하였으므로 수신할때는 이걸 다 합쳐야지 완성된 패킷이 되므로 위와 같은 Fragmentation을 해주기 위한 필드가 바로 ID, Flag, Fragmentation offset인 것 Header checksum은 만일 상위 계층에서 Header에 대한 신뢰성 정보를 얻고싶을 때 사용한다 - Datalink에서 Error Detection / Correction처럼 IP에서도 Header에 한정해서 에러가 났는지 아닌지 확인하기 위한 용도 왜 Header에 대해서만 에러를 판정하냐면 Network 계층에서는 Error detection보다는 패킷 전달에 목적이 있는데 만일 송수신 주소에 에러가 있으면 잘못된 주소로 패킷이 전달되기 때문에 Header에 대해서면 체크를 하게 되는 것 하지만 IPv4에서는 잘 사용하지 않는 필드랜다 Time to Live : 얘는 패킷이 네트워크에서 loop에 빠져서 계속 돌아다니거나 너무 먼 길을 돌아서 나중에 도착하는 것을 막기 위해 수명을 정해놓은 것이다 최대 255까지의 값을 설정하여 하나의 hop을 지날때마다 1씩 감소시키고, 이 값이 0이 되면 수명을 다한것으로 판단하여 폐기하게 되는 구조 Options § No operation HLEN을 적을 때 4바이트 단위로 적고, 물리계층에서 데이터를 송수신할때도 4바이트씩 병렬적으로 송수신하기 때문에 옵션들도 4바이트의 배수가 되께 하기 위해 넣어주는 일종의 패딩 위의 그림처럼 7바이트의 옵션이 있으면 NO-OP를 하나 채워 8바이트를 만들어준다 End of operation 얘도 비슷한 이유이다 - 어떠한 이유에서든 마지막에 1바이트가 빌때 Option의 길이를 4바이트의 배수가 되게 하기 위해 넣어주는 것 Record Route : 패킷이 거처간 라우터들을 전부 기록한 옵션 - 어디에서 트래픽이 몰리는지 등을 체크하는데 도움이 된다 Strict Source Route : Virtual circuit마냥 지나가야되는 Router를 전부 명확하게 명시해 해당 루트로 전송되게 하는 옵션 Loose Source Route : 지나가야되는 Router를 명시하되 얘네들만 지나가는게 아니고 다른 라우터를 거쳐서 이 라우터만은 반드시 거쳐가야된다는 것을 명시하는 옵션 Timestamp : 각각의 라우터를 지나가는데 걸린 프로세싱 시간 - 뭐 네트워크 관리 등을 하는데 중요한 정보가 된댄다 IPv6 § IPv6혹은 IPng이라는 것은 두가지의 장점이 있다 더 많은 주소 수용 가능 - 주소체계를 16바이트로 늘려 훨씬 더 많은 주소를 표현했고 따라서 IPv4에서의 2계층 구조(netid와 hostid)말고 더 계층을 세분화했댄다 On-demand hop-to-hop routing option : 얘는 IPv4에서처럼 option이 있지만 패킷의 모든 옵션을 다 꺼내봐야하는 IPv4와는 달리, 내가 봐야 하는 패킷만 볼 수 있고 따라서 더욱 빠르게 라우팅이 일어나게 된다는 것이다 따라서 위처럼 반드시 가지고 있어야 하는 40byte - Base header와 추가적인 옵션 - Extension header으로 구성됨 IPv4와의 차이점 § IPv4에 비해 바뀐 것을 간략하게 보면 HLEN필드는 사라졌다 - 헤더의 길이가 40바이트로 고정이므로 Service type필드는 → Priority and Flow label필드로 변경되었고 Total length필드는 → Payload length필드로 변경되었고 TTL필드는 → Hop limit필드로 변경되고 Protocol필드는 → Next header필드의 Next Header Code로 변경되어 하나의 패킷에 여러개의 protocol에 대한 data가 저장될 수 있게 했고 Header checksum은 어차피 TCP같은 계층에서 수행하기 때문에 사라졌고 Option필드는 → Extension header로 변경되었다더라 Extension header § 위와 같은 옵션들이 있음 뭐 Pad1, PadN은 IPv4에서의 NO-OP나 End of OP같은 alignment을 맞춰주기 위한 헤더이고 - Pad1은 1바이트짜리 패딩, PadN은 n바이트짜리 패딩 이 중에서 Source routing만 간략하게 보면 위의 그림에서 검은색 굵은선 박스가 Source routing의 내용인데 HELen은 뭐 Header extension length일거고 그 아래 Left는 앞으로 몇개의 라우터를 더 거쳐야 되는지를 의미한다 그리고 그 아래로 차례대로 가장 먼저 방문하게 되는 순서로 라우터릐 이름이 들어가게 된다 진행과정은 다음과 같다 패킷이 라우터에 도착하면 dst를 보고 자신이 맞는지 확인한다 자신이 아니라면 routing table을 이용해 다음 목적지를 설정하여 보내면 되고 - 즉, base header만 보고 안꺼내봐도 될거같은 헤더는 꺼내보지 않는다 이거야 만약 자신이 맞다면 그제서야 Source routing 에 있는 내용을 확인하게 된다 즉, Source routing에 있는 내용은 항상 꺼내볼 필요가 없고 dst가 자신이 맞을때만 꺼내보는 것 꺼내본 다음에는 자신의 주소를 Source routing에 적고 그 다음에 있는 라우터를 dst로 설정하여 송신하게 됨 위 그림에서 보면 I1에 도달할때까지는 Source routing의 내용을 참조하지 않다가 I1에 도달하면 그때 열어보게 된다 이후에는 I1를 Source routing에 적고 해당 위치에 있던 라우터를 dst로 하여 보내게 되는 것 그럼 그 다음 라우터에 도달할때까지는 Source routing을 열어보지 않는 것을 반복하게 되는 것 따라서 IPv6의 경우에는 위와 같은 헤더 구조를 갖게 되고 Next header의 경우에는 다음과 같은 값을 가진다 일단 Next header는 Next header code를 통해 뒤이어 나오는 옵션이 어떤 옵션에 속하는지 알려준다 Next header code는 그리고 IPv4에서의 Protocol field처럼 어떤 상위 프로토콜에서 전송되었나를 표현하는 수단이 되기도 한다 또한 Next header에는 다음 옵션에 대한 포인터가 저장되어 있어서 해당 헤더를 안봐도 되는 경우에 다음 옵션으로 손쉽게 넘어갈 수 있게 한다 Next header의 작동과정은 일단 Destination address가 라우터 자신의 주소와 같으면 Next header들을 전부 꺼내본다 그리고 자신의 주소와 같지 않으면 Next header를 전부 꺼내보지 않고 필요한 Next header들만 꺼내보되 자신의 주소와 같지 않을 경우에 Hop-by-hop option이 설정되어있는 경우에는 Next header를 전부 꺼내보게 된다 Hop-by-hop option이 모든 Next header들을 다 꺼내보라는 신호라고 생각하면 됨 .</description>
    <pubDate>Sun, 05 Nov 2023 09:55:00 GMT</pubDate>
  </item><item>
    <title>07. Address mapping, Multicasting, Error rep</title>
    <link>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/07.-Address-mapping,-Multicasting,-Error-rep</link>
    <guid>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/07.-Address-mapping,-Multicasting,-Error-rep</guid>
    <description> 충남대학교 컴퓨터공학과 김상하 교수님의 &quot;컴퓨터 네트워크&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 구어적 표현 이 포함되어 있을 수 있습니다. 개요 § ARP와 RARP는 Logical address와 Physical address를 매핑하는 Address mapping에 관련된 부분이고 RARP는 Application layer에 있는 BOOTP라는 놈과 연관이 있댄다 IGMP는 Multicasting에 관한 부분 ICMP는 Error Reposting에 관한 부분이다 - 네트워크상에서 Congestion(혼잡현상)이나 어떤 다른 에러가 일어나는지 알려줌 Address mapping - ARP, RARP (+ BOOTP, DHCP) § ARP § 이미 다 배운내용이니 기억 안나면 이거 확인해라 Two levels of addressing : 12.</description>
    <pubDate>Sun, 05 Nov 2023 09:55:00 GMT</pubDate>
  </item><item>
    <title>08. Transport Layer &amp; UDP</title>
    <link>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/08.-Transport-Layer-&-UDP</link>
    <guid>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/08.-Transport-Layer-&-UDP</guid>
    <description> 충남대학교 컴퓨터공학과 김상하 교수님의 &quot;컴퓨터 네트워크&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 구어적 표현 이 포함되어 있을 수 있습니다. Transport Layer § 위 그림에서처럼 호스트한테 도착한 이후, 호스트 내의 특정 프로세스로 데이터를 전달하기 위한 계층이 Transport layer이다 이것을 위해선 Port address가 있어 특정 port address로 데이터를 전송해 올바른 프로세스로 찾아가게 한다 즉, Process-to-Process Delivery를 위한 계층이 Transport layer인 셈 종류로는 UDP, TCP, SCTP가 있고 이중에 TCP가 제일 유명하지만 UDP나 SCTP를 사용할 수도 있댄다 Process-to-Process Delivery § 일단 용어정리를 좀 하면 IP주소가 A인 Host의 port a가 IP주소가 P인 Host의 port j로 보내면 Local host는 A이고 Remote host는 P이다 - Local host와 Remote host에서 host는 IP를 뜻하는 말임 Local process는 a이고 Remote process는 j이다 - Local process와 Remote process에서 process는 port를 뜻하는 거더라 Client-server model § 데이터를 받는 상대방의 port는 어떻게 알아내냐는 궁금증에 생기게 되는데 상대방의 port를 알아내는 방법으로 Client-server model을 사용하게 된다 일단 Client는 통신을 시작하는 쪽, 먼저 요청하는 놈 - Initiator이라고 생각하면 된다 일반적으로는 서비스를 요청하는놈이라고 생각해도 되지만 특별한 경우에는 서비스를 제공해주는 놈이 통신을 시작하기도 하더라 그리고 Server는 Client의 통신 / 요청에 대해 응답하는놈 - Responser이 된다 이때 Client-server model에서는 Server의 port를 이미 잘 알려진 값인 well-known port를 사용한다 뭐 알다시피 http의 경우에는 80을 사용하쥬 즉, Server가 well known port를 사용하기 때문에 통신을 시작하는 쪽인 Client는 Server의 port번호를 알 수 밖에 없다 따라서 Client가 well known port로 보내게 되면 Server는 그것을 받고 Client의 port번호를 알아낼 수 있기 때문에 정상적인 응답을 보내줄 수 있는 것 위에가 예신데 보다시피 Daytime 이라는 프로토콜에서는 Server가 13이라는 Well-known port를 이용하고 클라이언트는 이걸 알기 때문에 자신의 임시 port인 52000을 실어 보내면 Server가 알게 되는 것 클라이언트의 port는 임시적인거고 프로세스가 죽으면 다른 프로세스에게로 할당될 수 있다 - Ephemeral local port number라고 하더라 그리고 MAC, IP주소와 마찬가지로 port번호도 다른 계층에서 알 수 없는 것은 아니다 - port번호가 패킷에 담기는 자료구조를 모르는 것 일례로 IP주소가 Transport계층을 넘어 Application까지 넘어가는 경우가 있고 port라는 것도 Transport의 상위계층에서 넘겨주는 값이다 Address System § Port Number § IANA라는 기관에서 port번호를 정하는 규칙을 만들어놨댄다 보면 0~1024까지는 well-known 1024~49151까지는 Registered라고 해서 나중에 쓸 목적으로 비워둔 곳 49152~65535는 프로세스가 임시로 할당받게 되는 값이다 Socket Address § IP와 Port를 합친 주소를 Socket Address라고 한다 얘는 Application Layer에서 사용하는 주소 중 하나로 다른 계층의 주소를 사용할 수 있다는 것을 보여주는 또 다른 사례인 것 Multiplexer, Demultiplexer § Process들에게서 전달받은 데이터를 취합하여 IP로 보내는 Multiplexer와 받은 데이터를 다시 나눠 각각의 Process들에게 뿌려주는 Demultiplexer가 있댄다 Connection, Reliable § Connectionless vs Connection-oriented § 일단 앞에서 배운것처럼 Connection이라는 것은 데이터가 보내진 순서대로 도착하느냐 아니냐에 따라 나눠진다 Connectionless는 순서가 바뀌든 중간에 유실되든 상관 없이 전송되는 것을 의미 - UDP가 여기에 해당한다 그리고 Connection-Oriented는 순서가 바뀌면 안되고 보낸 순서대로 도착해야되는 것 - TCP과 SCTP가 여기에 해당한다 Connection-Oriented는 다음과 같이 작동함 일단 한놈이 Connection-Oriented하게 통신하자고 메세지를 보냄 그럼 그걸 받은놈은 버퍼를 준비하고 준비됐다고 답장을 보냄 통신시작하는쪽은 버퍼를 준비하며 알았다고 메세지를 보낸 뒤 데이터들을 보낼 순서대로 Numbering을 한다 - 순번을 다 적어놓는 셈 그리고 이걸 보내게 되면 받는쪽은 그걸 받아서 바로 Application Layer로 올리는게 아니고 일단 버퍼에 저장해둔다 그리고 데이터가 다 도착하면 그제서야 버퍼에 있는 데이터들의 순번을 보고 순서대로 Application Layer로 올려보내게 됨 그렇다고 Connectionless라고 해서 순서를 아예 무시하는건 아닐 수도 있다 - Transport계층에게 그걸 맡기지 않는다는 거지 Application Layer에서 자체적으로 하는 경우도 있다더라 Reliable vs Unreliable § 일단 Reliable은 다음과 같은 에러가 없을때를 지칭하는 말이다 Flow Control Error : 수신속도보다 송신속도가 더 빨라 Overwrite되는 경우 Physical Error : 노이즈가 끼는 경우 TCP, SCTP가 여기 해당함 당연히 Unreliable은 이러한 에러가 있을 수도 있을 때를 말하는 거겠지 UDP가 여기 해당함 이것도 마찬가지로 Unreliable하다고 에러를 무시할 수도 있지만 그렇지 않을 수도 있다 - Application Layer에서 자체적으로 하는 경우도 있다 이거야 근데 Data link layer에서 이런 것들을 해주는데 왜 Transport 계층에서도 하는지 의문이 들 수 있는데 그건 아래 예시 보면 알 수 있음 보면 일단 분홍색 선으로 표시된 부분에는 Data link layer의 활약으로 에러가 없음 근데 위 그림에서 검은색 선으로 표시된 부분에서 에러가 날 수 있다 이건 왜냐하면 Router에서는 Incoming queue에서 Outgoing queue로 패킷을 옮겨야 하는데 이 queue의 크기가 무한한게 아니기 때문에 패킷이 많이 쌓여 공간이 부족하게 되어 에러가 남 이런걸 Queue overflow by congestion, False Flow Control이라고 하더라 UDP § User Datagram Protocol(UDP) 는 IP에 Port를 추가해 Process-to-Process 기능만 덧붙이고 나머지는 아무것도 하지 않는 프로토콜이다 당연히 Process로 연결해주는것 외에는 아무것도 하지 않기 때문에 Connectionless, Unreliable하다 UDP에서 사용하는 Well-known port 들임 - 참고만 혀 헤더의 구조는 위와 같다 - 단순 근데 Total length는 굳이 필요 없다 - IP헤더의 total length부분에서 hlen을 빼면 구할 수 있기 때문에 하지만 Transport 계층의 정보를 얻기 위해 IP계층에 물어보는 것은 약간 자존심상해서 만들어놨댄다 구조 § 위 그림처럼 port 하나가 열리면 UDP에서는 Application과 데이터를 주고받을 Incoming queue와 Outgoing queue가 열린다 근데 이때 서버에서는 여러 Client로부터 데이터를 받기 때문에 Incoming queue를 하나만 사용하면 데이터가 어디에서 온 건지 알수 없게 되는데 왜 알수 없냐면 Application layer로 올라갈때는 Header가 제거되기 때문 그래서 UDP에서 Application으로 올릴때 Header를 뗀 Data뿐 아니라 Socket Address도 같이 주어 이놈이 어디에서 와서 어디로 가야되는지 Application layer로 보내준다 .</description>
    <pubDate>Sun, 05 Nov 2023 09:55:00 GMT</pubDate>
  </item><item>
    <title>09. TCP</title>
    <link>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/09.-TCP</link>
    <guid>https://mdg.haeramk.im/comnet.fall.2021.cse.cnu.ac.kr/09.-TCP</guid>
    <description> 충남대학교 컴퓨터공학과 김상하 교수님의 &quot;컴퓨터 네트워크&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 구어적 표현 이 포함되어 있을 수 있습니다. TCP Services § Process-to-Process Communication § 일단 뭐 Process-to-Process Deilivery를 지원하기 위한 port number를 사용하니까 Client-Server Model을 사용한다 TCP에서 사용하는 well know port는 80은 http, 53은 DNS라는것 정도는 알고 있어라 Stream Delivery Service § 그리고 TCP에서는 Stream Delivery Service라는 것을 사용하는데 이게 뭐냐면 UDP같은 경우에는 Application Layer로부터 내려온 데이터를 하나의 데이터그램으로 만들어서 보낸다 이걸 내용적으로 의미있는 단위로 데이터그램을 전송한다하고 표현함 하지만 TCP는 이렇게 하지 않고 Application Layer로부터 내려온 데이터들을 버퍼에 모았다가 버퍼가 일정 수준 쌓이면 그때 보내게 된다 즉, UDP처럼 내용으로 구분해서 전송하는게 아니고 버퍼에 쌓인 데이터의 크기로 구분해서 보내게 되는 것 따라서 여러개의 데이터가 하나의 단위로 묶여서 보내질 수도 있고 Application Layer에서 내려온 데이터가 많은 경우에는 얘네들을 잘라서 보내기도 하고 이런식이더라 뭐 예를들어서 Application Layer에서 두 프로세스가 각각 5byte, 1500byte의 데이터를 줬다면 UCP의 경우에는 5byte, 1500byte로 전송을 하겠지만 TCP의 경우에는 1000byte, 505byte로 전송을 한다 이말임 이렇게 하는 것의 장점은 항상 비슷한 크기의 많은 데이터를 송수신하게 된다는 것이다 이게 왜 장점이 되냐면 데이터를 보낼때는 그것만 보내는게 아니고 여러 계층의 헤더를 붙여서 보내기 때문에 한번 보낼때 최대한 많은 데이터를 보내는게 효율적이기 때문 만일 Header를 다 합쳤을때 100바이트라면 UDP같은 경우에는 메시지가 5byte와 800byte두개가 들어오면 105byte, 900 byte 두번이 전송되지만 TCP같은 경우에는 얘네들을 합쳐서 보내기 때문에 905byte 한번만 전송하게 된다 그리고 알아두어야할 게 Port별로 버퍼가 생성된다 - 어차피 Port들을 Multiplexing과 Demultiplexing을 다 하기 때문에 Port가 합쳐지는 것에 대한 생각은 하지 말고 Process-to-Process의 관점에서만 생각하면 된다 그리고 TCP는 Reliable한 전송을 보장하기 때문에 송수신 속도 차이에 따른 Flow error를 방지하고자 송수신측 모두 버퍼를 둔다 그래서 위 그림처럼 송수신측 모두 넉넉하게 버퍼를 준비해놓고 Sending process가 송신 버퍼에 쓰면 그걸 순차적으로 보내게 되고 받는쪽에서도 데이터를 받아 수신 버퍼에 쓰면 그걸 Receiving process가 가져가게 되는 구조 버퍼가 없다면 아직 보내지도 않았는데 Sending process가 데이터를 줘 Overwrite된다거나 수신측에서도 Receiving Process가 가져가지도 않았는데 데이터가 수신되어 Overwrite되는 일이 벌어지게 되는 것 위 내용을 종합해보면 위와 같은 그림으로 표현할 수 있다 송수신 속도 차이에 따른 Flow error를 막기 위해 송수신 버퍼가 존재하고 Message별로 데이터를 보내는게 아닌 일정 수준 크기로 데이터들을 뭉쳐 Segment라는 단위로 보내게 된다 Full-duplex Communication § Full-duplex communication은 TCP가 양방향 통신을 지원한다는 의미이다 Connection Oriented Service § 이전에 배운거처럼 TCP는 orderly delivery를 지원한다 그래서 일단 Connect Phase를 거치고 - 전송을 이제 시작할 것이니 송수신측 모두 버퍼를 준비해라 + 송신할 데이터에 numbering을 하여 순서대로 도착하지 않아도 수신측에서 number를 보고 정렬하여 상위계층으로 보낼 수 있도록 그리고 데이터를 송수신한 후 Disconnect Phase를 거쳐 준비한 버퍼를 삭제해 다른 통신에서도 사용할 수 있도록 함 Reliable Service § TCP는 Reliable Communication을 지원한다 - Flow &amp; Error Control을 하여 이러한 문제가 생기지 않도록 함 Numbering System of TCP § 일단 TCP에서 Numbering 하는 데에 중요한 것은 번호가 Segment별로 붙는게 아니라는 점이다 이게 무슨말이냐면 위에서 TCP에서의 전송 단위가 Segment라고 했는데 첫번째 보내는 Segment는 0번, 두번째 보내는 Segment는 1번 이런식으로 숫자를 붙이지 않는다는 것 이다 그럼 뭐 어떻게 하느냐 Byte 별로 번호를 붙이는 시스템을 이용한다 이걸 위해 두개의 필드가 헤더에 들어감 - Sequence Number하고 Acknowledge Number 얘네들은 Data link layer에서의 SEQ랑 ACK 번호랑 동일한 기능을 하는데 대신 번호를 매기는 단위가 Frame(Segment)가 아닌 바이트인 차이점이 있다 따라서 Sequence Number는 데이터의 첫번째 바이트에 붙는 번호이다 여기서 주의할 점은 Sequence Number는 0번부터 시작하지 않을 수도 있다는 점 - 0 ~ 2^31 - 1의 숫자 중 하나를 랜덤으로 골라 번호를 붙이게 된다 그리고 첫번째를 이렇게 붙이고 그 다음 바이트부터 1씩 증가하다가 2^31 - 1을 넘어가면 다시 0번으로 돌아와서 번호가 붙는 셈 당연히 Numbering이 이런식으로 된다는 거지 실제 Segment에는 첫번째 바이트의 Number인 Sequence number밖에 저장되지 않는다 그리고 Acknowledge Number는 Data link layer에서와 동일하게 이전까지는 잘 받았고 이제 이거를 보내달라는 의미가 된다 뒤에서 실제 예시를 보면 으케되는지 더 잘 알 수 있을거임 이런식으로 Byte-oriented Numbering System을 이용하기 때문에 Flow control과 Error control도 byte-oriented하게 이루어진다 뒤에 가서 어떻게 하는지 알려준댄다 Segment § 이게 Segment의 Header구조이다 위에서 언급 안한것만 살펴보면 HLEN은 헤더의 크기이다 - 근데 이것도 IP헤더랑 비슷하게 4-byte단위로 표시함 - 즉, HLEN이 1이면 헤더가 4바이트라는 거고 HLEN의 최대 크기가 15이기 때문에 최대 헤더의 크기는 60byte인데 Option and Padding을 제외한 필수적인 부분이 20byte이기 때문에 Option and Padding부분은 40byte 이내로 상황에 맞게 들어가게 된다 Reserved는 나중을 위해 비워둔 부분이고 주황색으로 표시된 Control이라고 불리는 Flag들은 Connection을 위해 있는 부분 Window Size는 Flow Control을 위해 존재하는 부분 Urgent Pointer는 뒤에서 배운댄다 Checksum은 Error control을 위해 존재하는 부분이랜다 A TCP Connection § Traffic이 막힌다던지 아니면 에러가 있어서 재전송을 하게 되는 등 전송의 순서가 바뀌게 되는 경우는 많다 그럼에도 불구하고 순서대로 데이터를 합치기 위해 Connection이 반드시 필요하게 됨 Connect → Data Transfer → Disconnect 순서로 수행된다 Connection Establishment Phase - Three way handshake § 일단 Connection단계에서는 Three way handshake라는 방식으로 Connection Establish를 하게 된다 이게뭐냐면 일단 Client가 통신하자고 Server에게 보내면 Server는 ㅇㅋ라고 하고 마지막으로 Client가 한번 더 확인차 ㅇㅋ라고 보내는 것 저렇게 세번 통신을 하여 Connection이 이루어지므로 Three way handshake인 것 위 그림 두개를 같이 봐야 한다 State Diagram을 볼 때는 점선 화살표가 Server, 실선 화살표가 Client인 것을 기억혀 그리고 edge에 붙어있는 라벨을 읽을 때 A/B이면 내가 지금 A를 했거나 A를 받은거고 그 다음에 B를 했다는 식으로 이해하면 됨 보면 Client가 Active open을 하고 Server한테 첫번째 악수를 날린다 Active open인 이유는 Client는 통신을 시작하는 주체이기 때문 - 적극적이다! 첫번째 악수를 날릴 때는 Control Flag의 SYN부분을 1로 만들어서 보낸다 그래서 저기 State Diagram에서 보면 Client는 Active open/SYN을 한 후에SYN-SENT상태에 진입하게 된다 그러면 Server는 Passive open을 하고 기다리다가 SYN을 받으면 Client에게 두번째 악수를 날린다 Passive open인 이유는 당연히 Server는 Client가 통신을 시작해야만 시작할 수 있으므로 수동적으로 통신을 열게 되는 것임 그리고 두번째 악수를 날릴 때는 Control Flag의 SYN부분과 ACK부분을 1로 만들어서 보낸다 그래서 State Diagram에서도 Server는 일단 **Passive open/-**이므로 수동적 통신 개시를 한 후에 LISTEN상태에서 기다리고 있다가 SYN/SYN + ACK을 한 후에 SYN-RCVD상태에 들어가게 된다 마지막으로 Client가 SYN + ACK를 받으면 세번째 악수를 날리며 Connection이 Establish된다 세번째 악수에서는 Client가 ACK하나만 올려서 보낸다 그럼 Server쪽에서는 ACK를 받았으므로 Connection establish를 하게 된다 그래서 Client쪽의 State Diagram을 보면 SYN + ACK/ACK을 하고 ESTABLISH상태로 가고 Server쪽의 State Diagram을 봐도 **ACK/-**를 하고 ESTABLISH상태로 가게 된다 그리고 여기서 Sequence Number하고 Acknowledge Number를 좀 유심히 봐야 하는데 첫번째 악수에서는 Client가 8000번이라는 난수를 보냄 - 처음으로 보낼때는 SEQ 에 그냥 난수를 하나 보내게 된다 두번째 악수에서는 Server가 SEQ 15000에 ACK로 8001번을 보내는 것을 알 수 있다 15000은 당연히 처음 보내는 것이기 때문에 난수이고 ACK가 8001이 되는 이유는 처음에 Client가 보낸 SEQ가 8000번이었으므로 이것을 잘 받았고 8001번을 나는 원한다는 뜻이 되는 거임 즉, ACK로 n을 받았으면 n - 1까지는 잘 받았고 이제 n을 보내주세요 라는 의미로 이해하면 된다 그리고 세번째 악수를 보면 Client가 여전히 8000을 보내고 ACK는 15001을 보낸다 뭐 ACK가 15001인 이유는 Server가 SEQ15000를 보냈기 때문이고 SEQ가 8000인 이유는 데이터를 보내기 위한 Segment가 아니기 때문이다 즉, 상대방의 ACK에 부응하여 그에 맞는 데이터를 보낼때는 상대방이 준 ACK를 SEQ에 넣어 데이터도 그에 맞는 것을 주지만 상대방에게 데이터를 보내는게 아닐때에는 SEQ로 ACK - 1을 주게 되는거 같음 그리고 ACK도 그냥 기계적으로 생각하면 편하다 - 상대방이 준 Segment를 잘 받았으면 그냥 그 다음거를 받기 원하는 거임 그리고 Control Flag에 대해서도 좀 정리를 해보면 SYN은 Connection을 하자는 의미인 거고 ACK는 방금 보낸 것을 잘 받았다는 의미인거다 따라서 첫번째 악수에는 Connection을 할건데 이전에 상대방이 보낸 것은 없으니까 SYN하나만 올라가있게 되는 것이고 두번째 악수는 Connection을 할거고 이전에 보낸 것을 잘 받았으니까 SYN과 ACK다 올라가 있는 것이다 그리고 세번째 악수는 Connection하자는 답변을 받았으므로 굳이 SYN을 올리지 않고 그냥 방금 니가 보낸거 잘 받았소 의 느낌으로 ACK하나만 올리게 되는 것 Data Transfer § 위의 예시에서 먼저 SEQ와 ACK를 보면 이제 데이터를 보낼꺼니까 상대방이 준 ACK를 반영해 SEQ에 8001을 넣어 데이터를 보내게 된다 그리고 방금 상대방이 준 것을 잘 받았고 이제 이걸 원한다는 의미로 ACK를 15001로 설정하는 것 여기서 데이터를 보내는데 ACK도 같이 보내는 이유는 TCP는 Full-duplex communication을 지원하므로 이런식으로 piggybacking을 할 수 있다는 것을 보여주기 위한 것 이다 즉, 데이터를 보냄과 동시에 ACK도 같이 보내 상대방도 ACK에 맞는 데이터를 보낼 수 있고 이런식으로 양방향 통신이 이루어지는 셈 - 이게 piggybacking인데 기억나시쥬? 위의 통신에서 두세번째를 보면 알 수 있다 - 두번째에서 방금 9000번까지 보냈으니까 이제 입벌려9001들어간다 느낌으로 SEQ 9001을 설정하고, 데이터와 함께 ACK 15001을 보내면 세번째에서 상대방은 그에 맞게 SEQ를 15001로 하여 자신도 데이터를 보내고 두번째에서 줬던 데이터를 잘 받았고 이제 10001을 원한다는 의미로 ACK를 같이 보내게 되는 것 마지막으로 네번째에서는 더 이상 보낼게 없으니까 SEQ는 그냥 마지막에 보낸 10000으로 하고 방금 보낸 데이터 잘 받았고 이제 17001을 원하고 있다는 것을 피력하기 위해 ACK를 17001로 설정해서 보내게 되는 것 그리고 Control Flag부분을 보면 상대방이 보낸 것에 대한 ACK가 Segment에 포함되어 있으므로 ACK FLAG를 올리게 된다 그리고 중요한게 저 PSH FLAG인데 이건 뭐냐면 TCP는 기본적으로 버퍼링을 해 버퍼에 일정수준의 바이트가 차기 전까지는 보내지 않고 받는쪽에서도 동일하게 어느정도 모이기 전까지는 Application layer로 올리지 않는다 받는쪽에서도 이렇게 기다리는 이유는 일단 Segment를 다 받고 정렬을 해서 올리기 위해서이기도 하고, 만일 데이터를 받을 Application이 바빠 지금 당장은 받지 못하는 경우에도 이렇게 기다렸다가 올리기 위해서이다 하지만 PSH FLAG가 올라가 있으면 기다리지 말고 바로 Application 으로 올리라는 의미를 가진다 보통 이것을 설정하는 것은 예를들어 채팅어플같은 실시간 통신이 중요할 때에는 기다리는 것이 곧 지연이기 때문에 이것을 막기 위해 바로 올려보내주세요 라고 하는 것이다 따라서 위의 예시에서는 첫 두 Segment에 PSH가 설정되어있으므로 쟤네들은 바로 Application으로 올라가게 된다 - 만약 이게 설정되어있지 않았더라면 첫번째는 버퍼에서 기다리고 두번째가 도착했을때 수신자의 판단 하에 Application으로 올릴 수 있는 것이다 위의 예시에서는 없지만 URG FLAG는 Urgent 즉, 긴급상황이 벌어진 것이다 이건 어떤 경우에 설정되냐면 예를들어서 큰 파일을 보내던 와중에 파일을 잘못보낸 것을 알고 이것을 취소하고자 할 때 사용한다 이런 상황이 생기면 TCP에서는 Special TCP Segment를 만들어 URG FLAG를 올리고 URG POINTER를 설정하여 데이터와 함께 보내게 된다 URG POINTER가 뭐냐면 위에 Segment Header구조 볼때 있던 필드인데 여기에 들어있는 값이 정상적인 데이터와 비정상적인 데이터를 구분하는 바이트 번호인 셈 즉, URG POINTER가 400이라고 되어 있으면 Segment의 데이터에서 400번째 바이트까지는 폐기해야되는 비정상적인 데이터이고, 그 이후에 나오는 바이트들은 정상적으로 수신해야 되는 데이터인 것 그래서 URG를 수신하게 되면 URG POINTER가 가르키는 곳까지 수신자는 폐기하게 된다 이렇게 하는 이유는 한번에 최대한 많은 데이터를 보내기 위함이다 - 문제가 생겼다고 문제가 있음을 알리는 Segment를 별도로 보내는게 아니고 문제가 있음을 알리면서 동시에 정상적인 데이터들도 보내고 싶으신거지 Connection Termination - Four-way Handshake(Half close) § Connection termination에서도 Establishment에서처럼 Three-way handshake로 할 수 있지만 요즘은 사용되지 않는댄다 그래서 요즘 사용하고 있는 방법은 Four-way Handshake(Half close) 라는 방법이다 그리고 위에서 언급한것처럼 Connection Termination단계에서 버퍼들을 반납하게 됨 위 그림이 통신 전반에 걸친 State Diagram인데 Established까지는 전부 배웠고 이제 그 아랫부분을 보면 된다 위와 같은 식으로 이루어짐 Client가 Active close를 하고 FIN FLAG을 올려서 Segment를 보냄 Establish때와 마찬가지로 항상 Client가 먼저 제안을 한다 뭐 FIN FLAG는 이름 그대로 이제 통신 그만하자 라는 뜻이다 State Diagram에서 봐도 Close를 하고 FIN을 보낸 뒤 FIN-WAIT-1상태로 들어간 것을 볼 수 있다 Server는 FIN을 받으면 알겠다고 ACK를 보내게 된다 State Diagram에서 보면 FIN을 받고 ACK를 날린 뒤 CLOSE-WAIT상태로 들어가게 된다 Client는 ACK를 받으면 아무것도 하지 않는다 State Diagram에서 보면 ACK를 받고 FIN-WAIT-2상태로 진입한걸 볼 수 있는데 이 단계가 뭐하는 거냐면 Client쪽은 데이터를 다 보냈어도 Server쪽은 Client가 요청한 데이터를 아직 덜 보냈을 수도 있기 때문에 Server가 마무리하는 단계가 되는 것이다 따라서 Client가 FIN-WAIT-2상태일때 Server는 못보낸 것들을 다 보내고 Client는 ACK를 날려 잘 받았다고 알려줌 Server는 마무리를 다 한 후에 FIN을 보낸다 State Diagram에서 보면 Close/FIN이라고 되어 있는데 이게 Close하는 동안 나머지 데이터를 전부 보내고 그 이후에 FIN을 보낸다는 것 FIN을 보내고 난 후에는 LAST-ACK상태로 들어가 ACK가 올때까지 기다린다 Client는 FIN을 받으면 ACK를 날리고 잠시 대기한다 State Diagram에서 보면 FIN/ACK후에 TIME-WAIT를 하는 것을 볼 수 있음 Server는 ACK를 받고 바로 Close로 들어간다 뭐 이제는 State diagram 설명안해도 되겠지 Client는 일정시간 기다린 후에 Close로 들어간다 Server는 바로 Close되는데 Client는 왜 일정시간 기다리는지 궁금하다면 대학원응안가 Flow Control § Window Size § 일단 TCP의 Flow Control에서 중요한 점은 Receiver의 요청에 의해 Sender의 버퍼 크기를 늘렸다 줄였다 한다는 것이다 이게 뭔소리냐면 만일 Receiver의 버퍼 용량이 5000이고 1000이 아직 Application으로 올라가지 못했다고 해보면 Receiver는 4000이상의 데이터를 받게 되면 버퍼가 터져나가게 된다 따라서 Receiver가 Sender한테 말하는 거임 - 4000이상 보내지 마라고 이때 Receiver가 사용할 수 있는 남은 버퍼의 크기를 rwnd라고 표현한다 또한 이러한 이유 말고도 다음 강의때 배울 cwnd라는 것도 있는데 이건 Congestion Window라고 네트워크의 혼잡도를 나타내는 것이다 - 네트워크가 혼잡하면 한번에 보내는 데이터의 양을 줄이라고 Sender에게 요청하는 것 이러한 일을 Segment Header에 있던 Window Size필드를 이용해 수행한다 Window Size필드의 값은 rwnd와 cwnd중 작은 값 으로 설정하여 Receiver가 Sender에게 요청하게 되는 것 - 두 값보다도 적은 사이즈로 보내야 정상적으로 수신할 수 있으므로 따라서 Sender의 버퍼를 보면 위와 같은 모양이 될 수 있다 일단 Window Size는 Receiver의 요청에 의해 9로 설정된 상태고 199까지는 전송했고 ACK까지 받은 애등 200~202까지는 전송했지만 ACK는 받지 못한 애들 그리고 203~208이 바로 전송할 수 있는 애들 209이후로는 Application한테 받았지만 Window size 제한때문에 보낼 수 없는 애들인 것이다 즉 위 그림에서 보이는것처럼 Window size가 정해져도 ACK를 받지 못한놈들 때문에 당장 보낼 수 있는 크기는 그것보다 작을 수도 있다는 것 ARQ § Flow Control이기 때문에 Data link layer에서의 Flow Control 방법을 사용하는데 Go-back-N ARQ가 아니라 Selective ARQ를 사용한댄다 기억안나면 06.</description>
    <pubDate>Sun, 05 Nov 2023 09:55:00 GMT</pubDate>
  </item>
    </channel>
  </rss>