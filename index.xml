<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>Madison Digital Garden</title>
      <link>https://mdg.haeramk.im</link>
      <description>Last 10 notes on Madison Digital Garden</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>(충남대) 컴파일러 개론 강의록</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/(%EC%B6%A9%EB%82%A8%EB%8C%80)-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EA%B0%9C%EB%A1%A0-%EA%B0%95%EC%9D%98%EB%A1%9D</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/(%EC%B6%A9%EB%82%A8%EB%8C%80)-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EA%B0%9C%EB%A1%A0-%EA%B0%95%EC%9D%98%EB%A1%9D</guid>
    <description>개요 § 강의 정보 § 강의 구분소속교수시기학부 수업충남대학교 공과대학 컴퓨터공학과조은선 교수님2021년 가을학기 실습 자료 § github://haeramkeem/Fall2021-CNU-Compiler 목차 § 01. 어휘분석 &amp; 토큰 02. 어휘분석기 만들어보기 03.</description>
    <pubDate>Sat, 04 Nov 2023 14:21:32 GMT</pubDate>
  </item><item>
    <title>01. 어휘분석 &amp; 토큰</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/01.-%EC%96%B4%ED%9C%98%EB%B6%84%EC%84%9D-&-%ED%86%A0%ED%81%B0</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/01.-%EC%96%B4%ED%9C%98%EB%B6%84%EC%84%9D-&-%ED%86%A0%ED%81%B0</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. 컴파일러 전반부의 과정 § 전처리기 : # include, # define, # ifdef등의 명령을 처리해서 전처리가 완료된 소스코드로 변환함 Lexical analysis Syntax analysis Semantic analysis Lexical analysis § 전처리가 완료된 소스코드를 하나의 문자열로 보고 문법적으로 의미있는 최소단위인 토큰 으로 쪼개는 과정 토큰은 다음과 같이 5개 정도의 종류가 있다 키워드나 연산자는 사용자가 마음대로 적는게 아니기 때문에 exact match가 가능하다 - if는 바로 분기문이라는 의미의 토큰으로 분류가 가능 하지만 식별자와 상수, 문자열의 경우에는 사용자가 지정하는 것이기 때문에 exact match를 할 수 없고 조금 더 처리를 해줘야 한다 어디까지가 하나의 토큰인지, 이놈이 어떤 역할을 하는놈인지 바로 알기 힘든 경우가 많다더라 토큰을 기술하는 방법 § 토큰을 기술하는 방법중 하나로 정규표현식을 활용한다 이것만 안까먹으면 너가 알던 정규표현식이랑 똑같더라 문제 ^a 100$ 해결못함 토큰을 인식하는 방법 § 그냥 정규표현식 라이브러리 사용하면 된다 근데 좀 더 원론적인 부분으로 들어와서 우리가 그 라이브러리를 만드는 입장일때 정규표현식으로 토큰을 인식하는 방법으로 FSA 를 사용한다 프언개에서 배운거다 - Finite State Automata 즉, 유한상태 오토마타를 의미하는 것 다시 복습해보자면 시작상태와 끝 상태가 있고 시작상태와 끝 상태 사이에는 유한한 상태들이 존재하며 특정 조건에 따라 상태가 전이되는 오토마타인 것 모든 정규식은 FSA로 표현될 수 있고 모든 FSA는 정규식으로 표현될 수 있댄다 토큰을 인식하는 절차는 기술된 정규표현식을 FSA로 변환하고 FSA대로 문자열의 문자 하나하나를 처리하게 된다 근데 FSA로 변환하는 과정에 NFA와 DFA를 거치게 된다 NFA와 DFA는 모두 FSA의 한 종류인데, FSA는 한 상태에서 뻗어나가는 edge(화살표)에 붙은 레이블(문자)에 대한 제약조건이 없다 즉, 하나의 상태에서 같은 레이블이 붙은 화살표가 여러개 있어도 된다는 소리이다 이때, 이것에 대해 제약조건을 준게 DFA이다 즉, DFA(Deterministic Finite Automata) 라는 것은 한 상태에서 뻗어나가는 edge의 레이블은 모두 달라야된다(Deterministic 해야 된다)는 것을 만족하는 FSA를 말한다 반대로 DFA에 포함되지 않는 FSA를 Non-DFA라고 해서 NFA 라고 한다 따라서 토큰 인식은 다음과 같은 순서를 따르게 된다 정규식을 NFA로 변환하고(변환 알고리즘이 알려져 있다) NFA를 DFA로 변환하고(이것도 알려져 있다) DFA를 돌려서 토큰을 인식하는 그리고 여러 정규표현식에 매칭되어 구분될 수 있는 토큰의 경우에는 Greedy하게 처리 = 제일 길이가 긴놈으로 처리하게 된다 토큰인식한 토큰을 처리하는 방법 § Lexeme이라는 자료형을 사용 - (토큰번호, 토큰값)의 형태로 처리하게 된다 위의 예제를 보면 if는 29번, 변수들은 1번, &lt;는 18번 등으로 처리된 것을 알 수 있고 키워드나 연산자의 경우에는 값으로 0이 들어가지만 변수나 상수는 값으로 그 키워드의 변수 / 상수가 들어가는 것을 알 수 있다 변수(상수)들에 대해 같은 번호를 쓰고 값을 다르게 하는 이유는 키워드나 연산자의 경우에는 exact match이지만 변수나 상수의 경우에는 사용자가 지정하는 값이기 때문이라고 생각할 수 있다 그리고 회색글씨처럼 변수번호를 지정해서 값으로 넣어주고 symbol table을 만들어주는 것도 가능한 방법이다 C언어의 구조체로 표현하면 대략 위처럼 된다 union은 타입스크립트에서의 union type과 비슷하다고 생각하면 된다 문자 배열 또는 정수가 저장될 수 있으며 이 문자 배열과 정수가 따로따로 메모리를 할당받는게 아니라 하나의 메모리 공간에 들어가게 되는 것 int number에 토큰 번호가 들어가게 되며 char id[] 에는 변수(식별자)의 경우 이름이 들어가고 int num에는 상수의 경우 그 상수의 값이 들어가게 된다 구문문석기 § 어휘분석기는 scanner()라는 함수를 제공하고 구분분석기가 이 scanner()함수를 호출함으로 다음 토큰을 받아오는 형식으로 구현된다 .</description>
    <pubDate>Sat, 04 Nov 2023 14:21:32 GMT</pubDate>
  </item><item>
    <title>02. 어휘분석기 만들어보기</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/02.-%EC%96%B4%ED%9C%98%EB%B6%84%EC%84%9D%EA%B8%B0-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EA%B8%B0</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/02.-%EC%96%B4%ED%9C%98%EB%B6%84%EC%84%9D%EA%B8%B0-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EA%B8%B0</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. C언어(와 비슷한거) 만들기 § Symbol § FSA § 읽어보면 이해되제? Domain § 이것도 알겟제 enum 써봤는데 상수 여러개를 한번에 정의할때 쓰면 좋더라 구현 § 일단 while(isspace())로 공백을 다 지움 그리고 superLetter()로 superLetter인지 확인하는데 이름이 superLetter인 이유는 식별자에 ‘_’ 도 올 수 있기 때문 superLetter인 경우에는 식별자나 키워드이므로 뒤이어 나오는 superLetter를 do-while문으로 다 받는다 그리고 ID_LENGTH보다 i가 크거나 같을 경우에는 입력된 것이 식별자나 키워드의 최대 크기인 ID_LENGTH보다 크다는 뜻이므로 구문 에러를 발생시킨다 정상인 경우에는 문자 배열에 널문자를 넣어 문자열을 완성시켜주고 마지막으로 입력받은 superLetter나 숫자가 아닌값은 ungetc()를 통해 다시 버퍼에 넣어줘 안읽은척 해준다 그 이후에는 keyword배열을 훑으며 입력된 것이 keyword 테이블에 존재하는지 확인하고 존재한다면 for문을 빠져나오게 해준다 만약 index가 NO_KEYWORD보다 작으면 keyword테이블에 존재한다는 뜻이므로 반환할 토큰의 토큰 번호를 index에 맞는 키워드의 토큰 번호로 채워준다 하지만 그렇지 않다면 식별자로 처리하기 위해 토큰 번호를 식별자의 토큰 번호로 설정해주고 토큰의 값에 입력된 것을 넣어준다 그리고 공백 이후 나오는 첫 문자가 superLetter가 아니고 숫자일 경우에는 정수로 처리하기 위해 반환할 토큰의 토큰번호를 tnumber로 해주고 토큰 값으로 문자를 정수로 바꿔 넣어준다 마지막으로 식별자, 키워드, 숫자도 아닐 경우에는 연산자이기 때문에 switch case문으로 어떤 연산자인지 알아내 토큰을 생성하게 된다 token.</description>
    <pubDate>Sat, 04 Nov 2023 14:21:32 GMT</pubDate>
  </item><item>
    <title>03. 구문분석 &amp; 파스트리</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/03.-%EA%B5%AC%EB%AC%B8%EB%B6%84%EC%84%9D-&-%ED%8C%8C%EC%8A%A4%ED%8A%B8%EB%A6%AC</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/03.-%EA%B5%AC%EB%AC%B8%EB%B6%84%EC%84%9D-&-%ED%8C%8C%EC%8A%A4%ED%8A%B8%EB%A6%AC</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. 구문분석 (Syntax Analysis &amp; Parser) § 토큰들을 저렇게 구조에 따라 Parse tree로 구조화시키는 것으로 생각할 수 있음 주어진 문장이 정의된 문법에 따라 생성될 수 있는지를 판별하는 과정 올바른 문장에 대해서는 Parse tree가 나오게 되고 틀린 문장에 대해서는 오류가 나오게 된다 Describing Syntax § CFG § 프로그래밍 언어 개론에서 배운 Context Free Grammar(CFG) 를 이용하여 구문을 기술함 CFG 는 아래의 4가지로 구성됨 N(Non-terminal) - 치환될 수 있는 기호 보통 알파벳 대문자나 &lt;stmt&gt; 처럼 &lt;&gt;를 이용해 N이라는 것을 표시 터미널 혹은 다른 논터미널의 집합이라고 생각하면 될거같다 프언개에서 경유지라는 비유가 딱 맞는듯 - 걍 중간과정인셈 T(Terminal) : 토큰이랑 비슷하다고 생각해도 됨(컴파일러에서 토큰이라 부르는 걸 계산이론에서 터미널이라 부르더라) - 치환될 수 없는 기호 작은따옴표나 큰따옴표를 이용해 T라는 것을 표기 이것도 프언개에서 종착지라는 비유가 잘 맞다 - 최종 결과를 이루는 요소인 셈 P : 생성(치환) 규칙 집합 왼쪽 → 오른쪽 : 왼쪽은 오른쪽으로 치환될 수 있음 어떤 N이 여러 T들로 치환될 수 있다면 | 를 써서 표현할 수 있음 예를들어 A → ‘0’, A → ‘1’이라면 A → ‘0’ | ‘1’이 되는 것 S : 시작 심볼 그리고 L(G) 를 이 CFG로 생성될 수 있는 모든 문자열의 집합 - 즉, 이 문법을 따르는 언어가 되는 것 CFG에는 →, &lt;&gt;, | 정도의 기호밖에 없다 : 이 외의 기호들은 다 그냥 터미널이라 생각하면 됨 - +, - 같은 기호들 걍 다 터미널이다 S → a | aS 는 정규식에서 a+ 와 같고 S → e | aS 는 정규식에서 a * 와 같다는거 외워노라(여기서 e는 empty) BNF § Backus-Naur Form(BNF) CFG의 문법을 간소화한 것 논터미널을 &lt;&gt; 기호로 표시, → 대신 ::= 기호 사용, 걍 문자열은 터미널 그리고 BNF에서 확장된 Extended BNF 라는게 있는데 이건 논터미널 ::= {뭐시기}숫자 형태가 추가된 것이다 - 뭐시기가 숫자만큼 반복된다는 의미를 가지고 있음 기존의 CFG나 BNF에서는 반복을 표현하기 위해 재귀적으로 정의하는 방법 말고는 없었는데 EBNF에서 재귀적인 방법 말고 반복을 표현할 수 있는 방법이 추가된것 그리고 java를 기반으로하고있는 ANTLR도 EBNF를 사용하는데 여기서는 * 나 +같은 정규식의 문법도 사용 가능하다 Determine Syntax § 문법에서 언어를 유도해 내는 것을 Derivation(유도) 라고 하고 어떤 문자열이 유도되는지를 확인하면 그 언어를 따르는 것이라 생각할 수 있음 Derivation § 위 그림을 쭉 읽어보면 이해가 될건데 주의할 점은 derive는 반드시 한번에 하나의 N만 치환해야된다는 점 - 프언개에서 배운거처럼 모호성이라는 것이 존재하기 때문 논 터미널이 여러개일때 치환하는 방법이 두가지 있다 Rightmost derivation : 오른쪽부터 유도 Leftmost derivation : 왼쪽부터 유도 유도의 방법이 중요한 이유는 모호한 문법의 경우에는 유도의 방법에 따라 다른 트리가 만들어지기 때문 그리고 문법에는 -&gt;를 사용했지만 유도할때는 =&gt; 를 사용한다는 점이다 Derivation tree § 그리고 이 유도를 추상화시켜서 그린 트리를 Derivation tree라고 한다 유도의 과정을 추상화시켰다는 것은 이 유도의 순서가 트리에는 나타나지 않는 다는 것을 의미한다고 볼 수 있다 Ambiguous § 일단 Ambiguous(문법의 모호성) 이라는 것은 어떤 문자열을 유도해내는 유도 트리가 여러개 존재할 경우 문법이 모호하다라고 한다 모호성을 해결하는 방법은 결과는 같지만 다르게 기술된 문법을 사용하는 것이다 즉, S -&gt; a == S -&gt; A, A -&gt; a인 것을 이용 1.</description>
    <pubDate>Sat, 04 Nov 2023 14:21:32 GMT</pubDate>
  </item><item>
    <title>04. Top-down 구문분석</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/04.-Top-down-%EA%B5%AC%EB%AC%B8%EB%B6%84%EC%84%9D</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/04.-Top-down-%EA%B5%AC%EB%AC%B8%EB%B6%84%EC%84%9D</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. Top-down 구문분석 § 시작심벌부터 시작해 가능한 좌측 유도를 다 해보는 것 물론 전부 다 하는건 아니고 하나씩 맞춰보면서 한다 a가 들어왔으면 a로 시작하는 생성규칙 중 첫번째꺼부터 해보는 것 매치되는 생성규칙이 없을 떄 Backtracking 을 함 바로 직전의 생성규칙을 롤백시키고, 토큰도 다시 Stream에 넣어주고 다른 생성규칙을 시도 따라서 Backtracking의 오버헤드는 매우 클 수도 있다 더이상 적용할 생성규칙이 없으면 틀린것으로 인식 예제 § accd에 대해 Top-down방식으로 구문분석을 하면 일단 시작심벌에서 a로 시작하는 규칙이 두개 있으므로 1번부터 해봄 그다음에는 c로 시작하는 규칙이 4번이므로 4번을 적용 논터미널이 더이상 없는데 매칭되지 않으므로 4번을 롤백, 3번을 골라도 안되므로 백트래킹 - 1번를 롤백하고 2번 적용 2번을 적용한 뒤 c로 시작하는것이 5번 규칙이므로 5번을 적용 적용후에 논터미널이 더이상 없고, 매치되므로 문법을 준수한다고 판단 LL파싱 § 일단 Left-to right, 즉, 왼쪽에서 오른쪽으로 읽어나가며 파싱한다 결과적으로 Left Parse 즉, 좌파스가 생성되게 된다 또한 LL파싱의 제일 중요한 특징은 Deterministic Parsing 이다 입력 문자가 하나 들어오면 해당 입력문자에 적용될 수 있는 생성규칙은 하나여야 된다는 것 예를 들면 위의 예제에는 S → aAd와 S → aB가 있으므로 a가 들어왔을 때 생성규칙이 두개가 가능하다 이러한 경우에 Deterministic 하지 않다라고 하는 것 입력문자와 생성 터미널이 다르면 백트래킹 안하고 걍 틀린것으로 간주 - 백트래킹을 안한다는 장점이 있지만 결정적이지 않은 경우에는 걍 파싱을 안한다 - 즉, 파싱할 수 있는 범위가 좁다는 단점이 있다 따라서 LL파싱은 조금이라도 결정적으로 파싱이 될 수 있는 가능성이 있는 문법만을 받아 결정적이지 않은 곳은 다듬어서 사용하고 입력문자당 적용될 생성규칙을 key-value쌍으로 미리 뽑아두고 파싱하게 된다.</description>
    <pubDate>Sat, 04 Nov 2023 14:21:32 GMT</pubDate>
  </item><item>
    <title>05. LL문법</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/05.-LL%EB%AC%B8%EB%B2%95</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/05.-LL%EB%AC%B8%EB%B2%95</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. LL 문법 § 일단 위의 정의는 LL 조건이라고 부른다. 그리고 저 |가 ß에만 묶여있는거다 - a | ß라는 소리 - 헷갈리지 말 것 어떤 문법이 모든 생성규칙에 대해 LL 조건을 만족하면 그 문법을 LL 문법이라고 한다 또한 LL 문법에 속하는 문법은 LL 파싱이 가능하다 즉, 모든 생성규칙이 LL 조건을 만족하면 왼쪽에서 오른쪽으로 파싱했을 때 결정적으로 좌파스가 나오게 된다는 소리이다.</description>
    <pubDate>Sat, 04 Nov 2023 14:21:32 GMT</pubDate>
  </item><item>
    <title>06. 구문분석기 만들기</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/06.-%EA%B5%AC%EB%AC%B8%EB%B6%84%EC%84%9D%EA%B8%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/06.-%EA%B5%AC%EB%AC%B8%EB%B6%84%EC%84%9D%EA%B8%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. LL(1) 파서 구현 방법 § Recursive descent parser 이름처럼 recursion을 이용하는 방법이고 Non-terminal마다 한개의 procedure(function이라고 이해해도 될듯)을 두는 방법으로 구현한다 장점은 직관적이고 쉽다는 것 단점은 생성규칙이 바뀌면 구문분석기도 바꿔야한다는 점이다.</description>
    <pubDate>Sat, 04 Nov 2023 14:21:32 GMT</pubDate>
  </item><item>
    <title>07. Bottom up parsing</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/07.-Bottom-up-parsing</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/07.-Bottom-up-parsing</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. Bottom-up parsing § 일단 Bottom-up방식이 더 강력하다고들 한다 - 더 엉망인 문법로 파싱이 가능하기 때문 Left-recursive한 문법을 보통 엉망인 문법이라고 하고 Bottom-up 방식은 이런놈까지 파싱이 가능하다 이것은 Bottom-up방식으로는 생성규칙을 선택하는 것을 더 많은 토큰이 들어올 때 까지 미룰 수 있기 때문에 그렇다 이 아래 그림을 보면 좀 더 이해될거임 Top-down방식은 스캔된 토큰을 가지고 루트까지 만들어지기 때문에 만들어야되는 트리가 더 크다 하지만 Bottom-up방식은 스캔된 토큰으로 만들 수 있는데까지만 만들기 때문에 만들어야되는 트리의 크기가 더 작기 때문 Bottom-up의 과정 § 일단 Bottom-up은 Terminal 심벌부터 시작하여 root인 시작 심벌까지 도달하면 성공적으로 완료가 된다 즉, 생성규칙의 RHS를 보고 매치된다면 LHS로 치환하는 과정을 반복하게 됨 Bottom-up은 왼쪽부터 역 유도를 하기 때문에 결과적으로 우측유도의 역순을 진행하는 것과 동일하며 결과적으로 우파스의 트리가 만들어진다 LL, LR § 일단 LL은 니가 Top-down에서 배운 그 LL이 맞다 그리고 LR파싱이 Bottom-up에서 사용하는 파싱 방식인데 위에 정리되어 있는 것을 좀 보면 LL, LR에 공통적으로 들어가는 L은 Left-to Right라는 소리이다 - 왼쪽부터 읽어나간다는 소리임 그리고 LL의 경우에는 좌측유도를 해 좌파스가 생성되므로 L이 하나 더 붙는 것이고 LR의 경우에는 우측유도의 역순을 해 우파스가 생성되므로 R이 붙게 되는 것 k는 뭐 전에 배웠던대로 몇개의 심벌을 보고 결정할지를 나타내는 lookahead이고 근데 여기서 중요한 것은 Top-down, Recursive decent(predictive), LL parsing은 전부 비슷한 맥락의 용어라는 것과 Bottom-up, Shift-reduce, LR parsing은 전부 비슷한 맥락의 용어라는 것 꼭 기억하덤둥 그리고 LL의 경우에는 루트를 먼저 방문하기 때문에 트리 방문 순서 중 Pre-order방식이고 LR의 경우에는 자식을 먼저 방문하기 때문에 트리 방문 순서 중 Post-order방식이다 Reduce, Handle § Reduce는 간단하다 - Derive의 반대가 Reduce인 것 즉, 생성규칙의 LHS를 RHS로 치환하는 것이 Derive였다면, RHS를 LHS로 치환하는 것을 Reduce라고 한다 따라서 Bottom-up 방식은 시작심벌이 나올 때까지 Reduce하는 과정이라고 이해할 수 있다 Handle은 Reduce될 부분을 의미하는 것 예를 들면 다음과 같다 A → aBc라는 생성규칙이 있을 때 aBc를 보고 A로 역유도 하는 것을 Reduce라고 하고 이때 aBc부분이 reduce되는 것이므로 이 부분을 Handle이라고 함 즉, Reduce는 동작이고 Handle은 동작이 아닌 특정 문장형태를 나타냄 Handle을 보고 이걸 토대로 생성규칙을 뒤져보면 Reduce할 수 있는 생성규칙을 찾을 수 있다는 소리 Ambiguous grammar § 일단 모호한 문법이라는 것은 Left / Right most derivation을 했을 때 여러 형태의 파스 트리가 생성되는 경우를 의미한다는 것 기억나제 이때 모호한 문법에 대해서는 Bottom-up parsing을 할 때도 모호한 상황이 일어나게 된다 바로 Handle이 두개 이상 존재해 어떤 놈을 Reduce할 지 알 수 없을때 Bottom-up에서의 모호함이라고 한다 위의 예제를 보면 E + E * id까지는 똑같은데 이때 id도 handle이 될 수 있고 E + E도 handle이 될 수 있다 - 이때 모호하다라고 하는 것 Shift &amp; Reduce § 얘는 Top-down에서의 pop &amp; expand와 유사한놈이다 Pop &amp; expand에서도 스택이 존재했고 여기서 pop과 expand를 반복하며 파싱을 했듯이 Shift &amp; Reduce에서도 스택이 존재하고 Shift와 Reduce를 반복하며 파싱을 하게 된다.</description>
    <pubDate>Sat, 04 Nov 2023 14:21:32 GMT</pubDate>
  </item><item>
    <title>08. yacc</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/08.-yacc</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/08.-yacc</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. yacc 의 구조 § yacc은 일단 Bottom-up방식의 구문분석기를 생성해주는 프로그램이라는 것을 알고 있을 것 그리고 LALR(1) 이라는 파싱 기법을 사용한다는 것 - LR(1)의 성능과 LR(0)의 가벼움을 적절히 취하는 파싱 기법 yacc은 .</description>
    <pubDate>Sat, 04 Nov 2023 14:21:32 GMT</pubDate>
  </item><item>
    <title>09. LR(0) 파싱 테이블,  SLR 파싱</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/09.-LR(0)-%ED%8C%8C%EC%8B%B1-%ED%85%8C%EC%9D%B4%EB%B8%94,--SLR-%ED%8C%8C%EC%8B%B1</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/09.-LR(0)-%ED%8C%8C%EC%8B%B1-%ED%85%8C%EC%9D%B4%EB%B8%94,--SLR-%ED%8C%8C%EC%8B%B1</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. LR Parsing table § 일단 파싱 테이블을 만드는 과정을 다시 정리하면 파서 상태가 될 수 있는 후보들 선정 - LR(0), Closure을 이용 파서 상태들 간의 Deterministic Finite Automata 정의 파싱 테이블로 변환 파싱 테이블을 만드는데 알아야 할 개념들 § LR(0) 아이템 § 얘는 생성규칙의 RHS에 찍을 수 있는 모든 곳에 점을 찍은 생성규칙을 의미한다 예시로 보는게 더 빠름 뭔지 알것제? Closure § 얘는 LR(0)아이템 집합을 인자로 받아 원소의 갯수가 더 불어난(혹은 동일할수도 있음) LR(0)아이템 집합을 반환하는 함수이다 일단 작동방식은 다음과 같다 하나의 LR(0)아이템에 대해 점(.</description>
    <pubDate>Sat, 04 Nov 2023 14:21:32 GMT</pubDate>
  </item>
    </channel>
  </rss>