<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>Madison Digital Garden</title>
      <link>https://mdg.haeramk.im</link>
      <description>Last 10 notes on Madison Digital Garden</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>(충남대) 컴파일러 개론 강의록</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/(%EC%B6%A9%EB%82%A8%EB%8C%80)-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EA%B0%9C%EB%A1%A0-%EA%B0%95%EC%9D%98%EB%A1%9D</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/(%EC%B6%A9%EB%82%A8%EB%8C%80)-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EA%B0%9C%EB%A1%A0-%EA%B0%95%EC%9D%98%EB%A1%9D</guid>
    <description>Table of Contents § 1. 어휘분석 &amp; 토큰 2. 어휘분석기 만들어보기 3. 구문분석 &amp; 파스트리 4. Top-down 구문분석 5. LL문법 6. 구문분석기 만들기 7. Bottom up parsing 8. yacc 9. LR(0) 파싱 테이블, SLR 파싱 10.</description>
    <pubDate>Thu, 02 Nov 2023 15:38:05 GMT</pubDate>
  </item><item>
    <title>1. 어휘분석 &amp; 토큰</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/1.-%EC%96%B4%ED%9C%98%EB%B6%84%EC%84%9D-&-%ED%86%A0%ED%81%B0</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/1.-%EC%96%B4%ED%9C%98%EB%B6%84%EC%84%9D-&-%ED%86%A0%ED%81%B0</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. 컴파일러 전반부의 과정 § 전처리기 : # include, # define, # ifdef등의 명령을 처리해서 전처리가 완료된 소스코드로 변환함 Lexical analysis Syntax analysis Semantic analysis Lexical analysis § 전처리가 완료된 소스코드를 하나의 문자열로 보고 문법적으로 의미있는 최소단위인 토큰 으로 쪼개는 과정 토큰은 다음과 같이 5개 정도의 종류가 있다 키워드나 연산자는 사용자가 마음대로 적는게 아니기 때문에 exact match가 가능하다 - if는 바로 분기문이라는 의미의 토큰으로 분류가 가능 하지만 식별자와 상수, 문자열의 경우에는 사용자가 지정하는 것이기 때문에 exact match를 할 수 없고 조금 더 처리를 해줘야 한다 어디까지가 하나의 토큰인지, 이놈이 어떤 역할을 하는놈인지 바로 알기 힘든 경우가 많다더라 토큰을 기술하는 방법 § 토큰을 기술하는 방법중 하나로 정규표현식을 활용한다 이것만 안까먹으면 너가 알던 정규표현식이랑 똑같더라 문제 ^a 100$ 해결못함 토큰을 인식하는 방법 § 그냥 정규표현식 라이브러리 사용하면 된다 근데 좀 더 원론적인 부분으로 들어와서 우리가 그 라이브러리를 만드는 입장일때 정규표현식으로 토큰을 인식하는 방법으로 FSA 를 사용한다 프언개에서 배운거다 - Finite State Automata 즉, 유한상태 오토마타를 의미하는 것 다시 복습해보자면 시작상태와 끝 상태가 있고 시작상태와 끝 상태 사이에는 유한한 상태들이 존재하며 특정 조건에 따라 상태가 전이되는 오토마타인 것 모든 정규식은 FSA로 표현될 수 있고 모든 FSA는 정규식으로 표현될 수 있댄다 토큰을 인식하는 절차는 기술된 정규표현식을 FSA로 변환하고 FSA대로 문자열의 문자 하나하나를 처리하게 된다 근데 FSA로 변환하는 과정에 NFA와 DFA를 거치게 된다 NFA와 DFA는 모두 FSA의 한 종류인데, FSA는 한 상태에서 뻗어나가는 edge(화살표)에 붙은 레이블(문자)에 대한 제약조건이 없다 즉, 하나의 상태에서 같은 레이블이 붙은 화살표가 여러개 있어도 된다는 소리이다 이때, 이것에 대해 제약조건을 준게 DFA이다 즉, DFA(Deterministic Finite Automata) 라는 것은 한 상태에서 뻗어나가는 edge의 레이블은 모두 달라야된다(Deterministic 해야 된다)는 것을 만족하는 FSA를 말한다 반대로 DFA에 포함되지 않는 FSA를 Non-DFA라고 해서 NFA 라고 한다 따라서 토큰 인식은 다음과 같은 순서를 따르게 된다 정규식을 NFA로 변환하고(변환 알고리즘이 알려져 있다) NFA를 DFA로 변환하고(이것도 알려져 있다) DFA를 돌려서 토큰을 인식하는 그리고 여러 정규표현식에 매칭되어 구분될 수 있는 토큰의 경우에는 Greedy하게 처리 = 제일 길이가 긴놈으로 처리하게 된다 토큰인식한 토큰을 처리하는 방법 § Lexeme이라는 자료형을 사용 - (토큰번호, 토큰값)의 형태로 처리하게 된다 위의 예제를 보면 if는 29번, 변수들은 1번, &lt;는 18번 등으로 처리된 것을 알 수 있고 키워드나 연산자의 경우에는 값으로 0이 들어가지만 변수나 상수는 값으로 그 키워드의 변수 / 상수가 들어가는 것을 알 수 있다 변수(상수)들에 대해 같은 번호를 쓰고 값을 다르게 하는 이유는 키워드나 연산자의 경우에는 exact match이지만 변수나 상수의 경우에는 사용자가 지정하는 값이기 때문이라고 생각할 수 있다 그리고 회색글씨처럼 변수번호를 지정해서 값으로 넣어주고 symbol table을 만들어주는 것도 가능한 방법이다 C언어의 구조체로 표현하면 대략 위처럼 된다 union은 타입스크립트에서의 union type과 비슷하다고 생각하면 된다 문자 배열 또는 정수가 저장될 수 있으며 이 문자 배열과 정수가 따로따로 메모리를 할당받는게 아니라 하나의 메모리 공간에 들어가게 되는 것 int number에 토큰 번호가 들어가게 되며 char id[] 에는 변수(식별자)의 경우 이름이 들어가고 int num에는 상수의 경우 그 상수의 값이 들어가게 된다 구문문석기 § 어휘분석기는 scanner()라는 함수를 제공하고 구분분석기가 이 scanner()함수를 호출함으로 다음 토큰을 받아오는 형식으로 구현된다 .</description>
    <pubDate>Thu, 02 Nov 2023 15:38:05 GMT</pubDate>
  </item><item>
    <title>10. LR(1) 파서,  LALR 파서</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/10.-LR(1)-%ED%8C%8C%EC%84%9C,--LALR-%ED%8C%8C%EC%84%9C</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/10.-LR(1)-%ED%8C%8C%EC%84%9C,--LALR-%ED%8C%8C%EC%84%9C</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. SLR의 문제점 § 위 그림을 보면 i2상태에 Reduce item과 Kernel item이 같이 존재하는데 그럼 이때에는 A → a로 reduce를 해야할지 shift b를 하고 5번 상태로 갈지 알 수 없다 즉 지금까지 봐온 예제에는 Kernel item이 reduce item이어서 별 문제가 없었지만 위 예제에서 보다시피 SLR으로 해도 Shift-reduce conflict를 피할 수 없더라 일단 위 그림만 보고 대강 진행과정을 생각할 수 있어야 한다 그림만 보고 할때는 Reduce를 하면 왔던대로 다시 갔다가 Reduce해서 생긴 논터미널로 움직여줘야되는것 잊지말 어쨋든 위의 예제에서 보면 ab같은 경우에는 2번에서 shift b를 하고 5번으로 가야되고 ac같은 경우에는 2번에서 Reduce A → a를 하고 0번으로 갔다가 3번으로 가야된다 하지만 2번에서는 A의 Follow에 b와 c가 모두 있기 때문에 SLR가지고는 위와같은 세밀한 컨트롤이 안된다 이거임 LR(1) Parsing § 이것을 해결하고자 그냥 Follow가 아니라 그 path를 타고 왔을때 Follow는 누구냐? 이 뭔소리여 어쨋든 그냥 Follow가 아니라 좀 더 조건을 세분화할 필요가 있는 것 따라서 LR(1) Item을 좀 변형해 해당 생성규칙으로 Reduce되었을 때 다음에 나와야 되는 토큰도 같이 명시하게 된다 이제는 그냥 Reduce를 하는게 아니라 그 다음에 나오는 토큰(Lookahead라고 부름)까지 확인을 하고 Reduce를 하는거고 따라서 그 다음 토큰 하나를 더 확인하기 때문에 LR(1) 이 되는거다 LL에서의 Lookahead와의 차이점은 LL(1)이면 그다음 토큰 하나를 보고 다음 액션을 결정해주는 것이었다면 LR(1)은 그 다음 토큰 하나를 보고 테이블을 만들겠다는 약간의 의미상으로 차이가 있다 LR(1) Item § 일단 LR(0) Item과의 차이점은 맨 뒤에 콤마(,)를 찍고 해당 생성규칙으로 Reduce를 한 다음에 기대하는 토큰이 명시되게 된다는 점이다 즉, LHS도 Reduce한 다음에 나올 토큰이기 때문에 SLR처럼 Follow를 고려해주는 셈이지만 SLR에서는 모든 Follow 원소에 대해 Reduce를 하는 것이었다면 여기서는 이제 Follow원소 중 부분집합에 대해서의 액션을 좀 더 세분화해서 명시하게 되는 것 따라서 위의 식의 의미를 생각해보면 X → a.</description>
    <pubDate>Thu, 02 Nov 2023 15:38:05 GMT</pubDate>
  </item><item>
    <title>11. SDD, AST</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/11.-SDD,-AST</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/11.-SDD,-AST</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. Semantic analysis 이전에 할거 § Lexical analysis와 Syntax analysis를 끝내면 그 결과로 나온 Parse tree로 Semantic analysis를 하는데 Semantic analysis로 들어가기 전에 Parse tree에 좀 살을 붙이는 작업을 한다 SDD(Syntax-Directed Definition) 혹은 SDT(Translation) 이나 AST(Abstract Syntax Tree) 의 도구를 이용하더라 Syntax Directed Definition / Translation (SDD / SDT) § 얜 뭐냐 과제에서 했던게 사실 SDD였던거임 - 어떤 생성규칙을 방문했을때, 그리고 빠져나왔을때의 Action을 설정해서 파싱 과정에서 다양한 정보를 생산할 수 있게 하는 것 따라서 생성규칙마다 Action을 적어놓으면 파싱 과정 혹은 파싱된 이후에 노드를 방문하며 Action들을 수행하게 된다 보통은 트리가 생성된 다음에 순회하지만 생성되면서 순회하는 방법도 있댄다 LR은 Bottom-up으로 생성되면서 하고 LL같은 경우에는 Recursive descent parser구현에서 심볼마다 할당된 함수가 return될때 방문하게 됨 그럼 이 Action은 어떻게 적느냐 Non-terminal마다 ‘값’이 있고 그 ‘값’들로 코드를 짜면 그게 Action이 됨 이렇게 말하면 뭔 소린가 싶은데 이게 Yacc / Bison에서의 예시임 보면 일단 생성규칙이 있고 {} 에 Action을 적어주게 되는데 Yacc에서는 RHS의 값은 저 $$ 라는 변수에 저장되게 되고 LHS는 앞에서부터 차례대로 $n 의 변수에 저장되게 된다 위 그림처럼 된다는거임 따라서 위의 예시에서는 RHS의 값인 $$ 으로 첫번째 expr의 값인 $1 과 두번째 expr 값인 $3 을 더하게 되는 것 여기서 주의할점은 여기에서 등장하는 변수들은 scope가 해당 생성규칙에 한정된다는 것 뭔소리냐면 만약에 $1 이 10이고 $3 이 30이었다면 $$ 의 값은 40이 되것지 근데 이때의 root는 또 다른 서브트리의 leaf가 될 수 있것지 그럼 그때 40이라는 값은 $$ 에 저장되는게 아니라 $n 에 저장된다는 거다 즉, 하나의 서브트리에 한정해서 루트의 값이 $$ 이고 리프의 값이 $n 이 된다는 소리임 위 그림 보면 뭔소린지 감은 잡힐거임 뭐 Terminal에 대해서는 값이 없다고 생각할 수 있는데 Lex에서 던져주는 식으로 값을 가져올 수도 있댄다 - 따라서 Terminal에 대해서도 별도의 변수가 할당되어 있는 것 ANTLR에서는 위처럼 표현된다는거임 ANTLR는 파싱트리가 생성되고 난 후에 Post order traversal로 순회하며 Action을 취한다 따라서 BaseListener라는 클래스 원형과 Listener 라는 인터페이스를 제공하여 얘네들을 상속 / 구현해 Action들을 명시하게 되어 있음 생성규칙 서브트리로 진입했을 때와 나갔을때 호출되는 enter뭐시기, exit뭐시기 메소드들이 있고 얘네들 안에 코드를 적어주면 그 코드가 실행되는 것 자세한건 과제 참고해라 Attribute § 위의 예제에서는 $$, $n 의 값이 정수인것으로 가정했는데 $$, $n 을 정수가 아닌 구조체로 명시할 수도 있다 - 이때의 구조체 Property를 Attribute 라고 부름 val이라는 Attribute가 있다고 어딘가에서 명시했다는 가정 하에 위처럼 사용할 수 있는 것 Attribute를 명시하는 방법은 위처럼 하면 된다 일단 Lex에서도 yylval에 해당 Attribute가 있다고 생각하고 코드를 짠 후에 yacc의 선언부(맨 위)에 %union {} 으로 Attribute 목록을 적어주고 각각의 심벌들에 대해서 어떤 Attribute를 가지는지 명시해줄 수 있는 것 근데 중요한점은 위에서는 구조체라고 했지만 사실은 Union type인 것 - Attribute마다 각각의 메모리가 잡히는게 아닌 메모리를 한덩이 잡아놓고 Attribute 각각에 따라 자료형만 바뀌는거다 즉, 하나의 심벌이 여러개의 Attribute를 가질 수는 없는 셈 따라서 위처럼 명시하게 된다 - $$, $n 를 union type으로 명시하고 각각의 심벌마다 specific type을 지정해 주는 셈임 심벌 각각에 Attribute를 지정해 줄 때는 Non-terminal일때는 %type &lt;attr&gt; N 이런식으로 명시하고 Terminal에 대해서는 %token &lt;attr&gt; T 이런식으로 명시한다 Attribute의 종류 § 이런 생성규칙에 대해 위처럼 children의 attribute를 이용해 parent의 attribute를 채우는 경우 Synthesized Attribute라고 부르고 parent, sibling의 attribute를 이용해 child의 attribute를 채우는 경우 Inherited Attribute 라고 부른다 Synthesized Attribute 의 경우에는 Bottom-up방향으로 attribute값이 propagation되고 Inherited Attribute 의 경우에는 Top-down방향으로 attribute값이 propagation되게 된다 당연히 Terminal의 경우에는 Synthesized Attribute밖에 가지지 않는다 SDD를 이용한 자료형 선언 예시 § 일단 위의 예시에서 intType과 floatType은 상수로 선언되어있다고 가정한다 그리고 AddType(id, type)이라는 함수를 이용해 해당 id(변수)의 자료형으로 type을 가지게 한다고 가정한다 마지막으로 D1저거는 그냥 D랑 똑같다고 생각하셈 - recursive declaration 이어서 RHS랑 이름이 겹치니까 걍 좀 다르게 적었다는 느낌 그럼 이 예시에서는 Bottom-up방식으로 propagation되며 변수의 자료형이 선언된다는 것을 알 수 있을것이다 RHS의 attribute를 채울 때 LHS의 attribute값을 이용하면 Bottom-up방식으로 attribute가 채워지며 propagation된다 위의 예시에서 D의 타입도 지정해주는 이유는 두번째 생성규칙 보면 D가 재귀적으로 나오고 그 뒤에 id가 뒤이어 오기 때문에 D뒤에 나오는 id는 D의 타입을 따르게 해주기 위함 또 다른 예시임 이번에는 자료형 명시부분 T와 변수 명시 부분 L로 나누어 TL로 D가 표현되는 방식인데 보면 위의 예시에서는 Bottom-up 방식 뿐 아니라 Top-down방식으로도 propagation되며 자료형이 선언된다는 것을 알 수 있다 LHS의 특정 attribute를 채우는데 RHS가 사용된다면 이때는 Top-down 방식으로 attribute가 채워지면 propagation되는 것 AST(Abstract Syntax Tree) § 뭔지는 프언개때 배워서 알거임 Parse tree에서 문법적인 부분은 모두 제거하고 의미적인 부분만 남겨서 트리구조를 단순화시킨 것 보면 괄호같은 경우에는 우선순위를 잡아주는 역할을 하는데 파스트리에서는 트리의 깊이도 우선순위가 녹아있기 때문에 다 제거가 되고 Non-terminal의 경우에도 Terminal로 바로 치환해서 불필요한 것들을 다 제거하게 된다 구현 예시 § 일단 자바로 짠 자료구조이다 객체지향 언어에서는 Polymorphism을 이용해 저래 표현할 수 있다더라 이건 C로 짠 코드인데 객체지향 언어가 아닌 경우에는 임의 자료형 자식 n개를 갖는 것을 표현하기 어렵댄다 자바같은경우에는 뭐 임의 자료형을 일반화해서 하나로 묶는게 되지만 C언어에서는 안되니까 임의 갯수의 자식을 가지는 것을 표현하기 위해 저렇게 N-ary tree를 binary tree로 바꾸는 방법을 이용한다 자식 포인터와 형제 포인터 두개만으로 n번째 자식에 도달하기 위해서는 첫번째 자식으로 간 다음에 링크드 리스트마냥 쭉 옆으로 따라가는 것 AST 만들기 § LL파싱 하는 와중에 만들기 § 왼쪽 위에가 옛날에 배운 Recursive descent parser이고 오른쪽 아래가 AST생성하는 버전 자식이 준 AST 서브트리를 모아다가 합쳐서 반환하는 방식으로 구현 LR 파싱 하는 와중에 만들기 § AST이기 때문에 당연히 의미있는 것에 대해서만 Node를 생성함 그래서 위처럼 Shift-reduce할때 의미있는 Terminal을 Shift할때 단말 노드를 만들고 의미있는 생성규칙을 Reduce할때 단말 노드를 합쳐 Subtree를 만든다 그래서 좀 더 자세히 보면 위처럼 됨 일단 심벌들마다 추가적인 공간이 있어 여기에 서브트리가 저장이 되고 Reduce되고 난 뒤에 트리가 저렇게 합쳐지는 것을 볼 수 있음 SDD로 만들기 § 별거 없다 node라는 attribute가 있어서 각각 expr에 대한 서브트리를 저장 하게 되고 Action에서 자식의 노드를 이용해 나 자신의 노드를 채우는 연산을 수행 하게 된다 Evaluation § Parse Tree혹은 AST에서 각각 노드를 방문하며 명시된 Action을 작동시키는 것을 Evaluation 이라고 하는데 그 방법중 하나로 On-the-fly Evaluation 은 AST Node 방문 순서대로 Evaluation하는 것인데 가장 효율적이긴 하나 제약조건이 있다 S-attributed SDD : Synthesized Attribute만 가지고 있는 경우 L-attributed SDD : Synthesized Attributed와 더불어 parent가 아닌 sibling attribute 만 이용해 attribute를 계산하는 경우 위 두가지 경우에만 Evaluation이 가능하다 .</description>
    <pubDate>Thu, 02 Nov 2023 15:38:05 GMT</pubDate>
  </item><item>
    <title>12. IR</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/12.-IR</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/12.-IR</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. Intermediate Representation § 고급언어와 기계어와 무관한 언어이고 Tree나 Instruction List의 형태를 띄고 있댄다 TreeNode나 Instruction이 적어야 최적화나 번역에 좀 더 유리함 그리고 위에서 보는것처럼 여러 종류를 사용해 표현 - 소스코드와 가까워 보통 코드 최적화의 역할을 위한 HIR(High IR) 와 기계어에 좀 더 가까운 LIR(Low IR) 로 사용한댄다 High Level IR § 일단 High Level과 Low Level은 상대적인 개념으로 명확하게 나누어져있는 경우도 있지만 그렇지 않은 경우도 있고 3개 이상의 IR을 사용할 때도 있댄다 High Level IR 은 형태나 표현력은 AST와 동일하나 여기에 반복문 처리나 함수 복붙 등의 추가적인 연산을 더 해주게 된다 위처럼 변수 자료형에 맞게 변환해주는 기능도 함 즉, 좀 더 구체적이게 AST를 변형해 Node를 추가하게 됨 Low Level IR § RISC같은 assembly language를 흉내낸 단순한 Instruction들로 구성된다 따라서 arithmetic(+logic, unary)연산, data movement(뭐 move, load, store같은)연산, 함수 call / return, goto등의 기능을 제공하는 instruction들로 구성된다 Low level IR의 종류 § N-tuple 표기법으로 표현할 수 있음 - 지금은 4-tuple인 Quadrauple 을 주로 사용한댄다 얘는 (연산자, 피연산자1, 피연산자2, 결과) 이렇게 4개를 튜플로 묶어 하나의 Instuction을 표현하는 것 이전에는 결과를 저장하지 않고 그냥 명령의 주소로 결과를 퉁치는 방법인 3-tuple방법이 유행이었으나 최적화시에 명령의 주소가 바뀌는 경우가 많아 문제가 됨 근데 이제 Quadruple 의 경우에는 결과를 할상 저장해야되므로 임시변수 문제가 생기게 된다 뭐 저장할 필요가 없는데 저장해야 되는 문제가 생긴다네 - 컴파일러 최적화하는 것으로 해결이 가능하다네 그리고 Tree로 표현하는 것도 가능하고 - 얘는 기계어 생성에 용이하댄다 JVM용 언어같은 애들도 중간언어로 분류한다면 얘네들은 Stack Machine Code 라고 부른다 - 기계어와 매우 흡사함 - 뭐 AST로부터 생성이 용이하다네 Quadruple(3-address) code § OP를 제외하고 연산자 두개와 결과를 저장할 메모리 주소 3개가 필요하므로 3-address code 라고도 불린다 반드시 3개여야되는건 아님 - 3개 이하여야 된다 - Unary operation은 피연산자가 한개니까 위처럼 HIR을 변환해서 Quadruple로 만들 수 있다 무조건 연산자 하나와 피연산자 두개(혹은 하나), 그리고 그의 결과로 표현하는 방식 여기서 t1, t2들이 임시변수 이다 - 연산 하나에 대한 결과를 임시적으로 저장해 사용하기 위한 것 Instructions § 보면 뭐 별로 새로울건 없고 여기서 [] 는 C언어에서 * 에 대응되는 dereference라고 생각하면 되고 addr 는 C언어에서 &amp; 에 대응되는 reference라고 생각하면 된다 이전까지 봤던 Instruction들과 크게 다를건 없다 Function call의 경우에는 인자때문에 엄밀하게는 3-address는 아니지만 여기에 포함시키기도 한댄다 따라서 Quadruple은 어떤 상상속의 기계에서 작동하는 Instruction이라고 생각해도 된댄다 3-Address code : GIMPLE, LLVM § GIMPLE § 일단 뭐 gcc는 3개의 IR을 거쳐 컴파일하고 GIMPLE은 gcc의 3-address 중간언어다 뭐 저기 보면 &lt;&gt;사이에 값 4개 들어가있제? Quadruple이라는 소리다 예시임 - GCC는 C언어를 이렇게 컴파일한다 LLVM Bit Code § 너가 coc깔때 clangd를 llvm으로 깔았잖어 이놈이 그놈임 clang 의 중간언어가 LLVM Bit Code이다 장점으로는 뭐 최적화가 잘되어있고 인터페이스가 깔끔해 Frontend와 Backend를 붙이기 좋댄다 LLVM Bit Code는 위처럼 생겼다 i32는 자료형과 자료형 크기를 나타내는 거임 - unsigned이기 때문에 32비트 integer여서 i32인것 @ 는 전역변수를 나타내는 것인 % 는 지역변수를 나타내는 기호임 그리고 여기서도 add쪽 보면 Quadruple을 사용하는 거 알 수 있고 alloca는 memory allocation, align 4라는 건 4의 배수가 되는 주소에 할당하라는 소리 global 은 전역변수에 대한 memory allocation이고 nounwind 는 Exception이 발생하지 않는다는 것 struct 선언은 선언부를 그대로 먼저 적어주고 type { i32 }는 값이 아닌 자료형이고 그 안에 i32가 하나 들어가있다는 의미 배열은 [숫자 X 자료형] 형태로 표현되고 zeroinitializer 는 전부 0으로 초기화 어쨋든 저거 읽어보면서 3-address code 번역하는거 연습해라 - LLVM은 아니어도 뭔가 번역하거나 역번역하는거 시험에 나올삘 Stack Machine Code - JVM Byte Code § 일단 Stack Machine 은 JVM생각하면 편하다 가상머신으로 Stack Machine을 하나 만들고 여기에서 돌아가는 Assembly code로 컴파일한 것이 Stack Machine Code 인 것 일단 왜 이름이 Stack Machine 이냐면 위와같은 구조때문에 그렇다 일단 위의 구조는 메소드 하나의 구조임 지역 변수는 배열 형태로 저장하고 오른쪽 아래 부분은 Constant pool 로 전역변수와 상수가 저장된다 그리고 Operand Stack 은 쉽게 설명하면 임시변수 스택이라고 생각하면 된다 하지만 임시변수는 생성되지 않는데 그 이유는 그냥 이 스택에 Push하면 임시값이 저장되고 Pop해서 임시값을 가져오기 때문 따라서 임시변수가 생성되지 않아 코드가 더 깔끔해진댄다 JVM Byte Code 예시 1 § .</description>
    <pubDate>Thu, 02 Nov 2023 15:38:05 GMT</pubDate>
  </item><item>
    <title>13. 3 Address code</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/13.-3-Address-code</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/13.-3-Address-code</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. HIR to LIR § 기호 [[ ]] 를 LIR = [[HIR]] 로 정의한다 이때, [[ ]] 안에는 C언어같은 고급언어 표현식이 들어가고 그의 결과로 LIR이 나오는 연산자인 것 위 그림에서 보이는 것처럼 t = [[variable]] 은 변수의 값을 주소공간 t에 넣으라는 의미가 된다 Expressions § Binary Operation § e = e1 OP e2 에 대해 t = [[e]] 는 t = [[e1 OP e2]] 가 되고 이것은 곧 t1 = [[e1]] t2 = [[e2]] t = t1 OP t2 의 형태로 재귀적으로 연산된다는 것 Unary Operation § 마찬가지다 e1의 값이 [[ ]] 를 통해 재귀적으로 구해지고, 그것을 OP로 연산하게 됨 Array Access § v의 타입이 T이고 T 타입이 차지하는 메모리 크기(sizeof T)를 S라고 할때 일단 v의 시작주소를 구해주고 C언어에서는 v가 곧 시작주소를 의미하지만 다른언어는 그렇지 않으니까 e의 값은 [[ ]] 로 재귀적으로 구해주고 재귀적으로 구해준 e에 S를 곱해 offset을 구하고 시작주소와 offset을 더해 원하는 주소를 구해준 뒤 결과값을 담을 주소인 t에 load해주면 끝 [] 연산은 C언어에서 dereference와 같다 - * 임 t = *t4 인 셈인거지 여기서 주의할 점은 우리 수업에서 t~ 는 임시 공간을 의미하는 것이고 이것이 주소인지 그냥 값인지는 문맥으로 파악해야 된다 위의 예시에서 t4는 주소값이기 때문에 해당 주소에 있는 값을 t에 저장하게 되는 것 Structure Access § 간단하다 v의 시작주소를 구하고 structure 내에서 f의 위치(offset)인 S를 더해 load해주면 되는 것 Short-circuit OR § Short-circuit OR 는 C언어의 || 연산을 의미하는 거다 즉, 앞부분이 참이면 뒷부분을 연산하지 않고 무조건 참을 반환하고 거짓이면 뒷부분의 값을 반환하는 구조 따라서 앞부분이 참이면 뒷부분이 실행되지 않기 때문에 조심해야된다더라 어쨋든 이걸 LIR로 바꿔보면 [[e1]] 을 계산한다 e1 계산값이 참이면 Lend로 점프하고 거짓이라면 [[e2]] 를 계산해 결과값으로 넣어준다 Short-circuit AND § Short-circuit AND 도 C언어에서의 &amp;&amp; 연산을 의미하는거임 앞부분이 거짓이면 뒤에를 연산하지 않고 결과는 무조건 거짓이고 앞부분이 참이면 뒷부분의 결과가 전체의 결과가 되는 셈 따라서 t = [[e1 SC-AND e2]] 는 이정도로 번역될 수 있다 t = [[e1]] t1 = NEG t cjump t1 Lend t = [[e2]] Lend: Statement § 프언개에서 배운것처럼 결과로 값이 나오는 것을 Expression이라고 하고 결과로 상태가 바뀌는 것(변수의 값이 바뀐다던가)을 Statement라고 한다 Statement Sequence § 단순하게 이어주면 됨 Assignment § 걍 변수에 값을 넣는 것은 당연하게도 위처럼 된다 배열에 값을 넣는 것은 위 그림에서 t4까지가 적재될 주소를 찾는 과정이고 t5 = [[e2]] 로 e2값을 구해서 저장한 뒤 [t4] = t5로 t4의 위치에 넣게 되는 것 If then else § 보면 이해되긴할건데 이 트릭은 좀 기억해둘 것 - e의 결과를 반대로 해서 e가 참일때는 cjump를 안하고 e가 거짓일때 cjump를 해서 s의 계산을 건너뛰게 된다는 것 if-then-else의 경우에도 e가 참일때는 cjump를 안하고 Lthen이 실행된 후 Lend로 점프하고 e가 거짓일때만 Lelse로 cjump를 하게 된다 While § 이것도 간단하다 여기서도 결과뒤집기 트릭을 이용한다 e를 계산하여 거짓이면 뒤집어 참이 되므로 cjump에 걸러 Lend로 가고 e가 참이면 뒤집어 거짓이 되므로 cjump에 걸리지 않아 연산이 됨 그리고 s를 계산한 후 jump를 이용해 다시 e를 계산하는 것으로 되돌아오는 식 Switch § switch문도 비슷하게 neq 를 이용해서 같지 않으면 cjump로 다음 것으로 넘어가고 같다면 cjump에 걸리지 않고 아래 문장이 실행되는 구조 근데 switch문은 Table lookup을 이용해서 구현되기도 한댄다 얘처럼 Hash Table이 있고 값과 주소가 저장되어있어 매칭되는 값의 주소로 바로 jump하게 되는 구조 O(1)이어서 좋긴 하나 보안에 취약하고 컴파일러가 최적화하기 어렵다는 일장일단이 있다 Function call &amp; return § 보면 쉬운데 이건 왜냐하면 call이랑 return이라는 keyword가 있다고 가정하기 때문인 것 - call이랑 return이 구체적으로 어떻게 더 low하게 번역되는지는 나중에 배움 Statement Expression § 이건 말그대로 상태도 바뀌고 결과값도 반환되는 것이다 Block statement, If-then-else statement, Assignment statement이 세개에 대해서 Expression화 시킬 수 있다더라 결과적으로 위처럼 s의 결과가 t에 담기게 됨 읽어보면 바로 알 수 있다 이전에는 [[s]] 로 statement를 계산만 했다면, 이제는 그걸 변수 t에 저장 위의 예시에서 봐야될게 이전에는 if-then-else 할때 e를 neg로 뒤집어서 거짓일때 cjump에 걸리게 했는데 이번에는 neg를 안써서 참일때 cjump에 걸리게 했다는 차이점이 있다 이건 Statement expression이라서 이렇게 번역했다기보다는 이렇게 했을때 Instruction 갯수가 하나 줄어드니까 이렇게도 한다는 것을 그냥 보여주기 위한거인듯 Nested Expression / Statement § 말그대로 중첩된 Expression을 말한다 - 시험에서 정답을 쓸 때는 [[ ]] 기호가 있으면 안되고 그걸 다 3-Addr-Code로 바꿔야 함 뭐 별 다른 개념은 없고 팁은 전체적인 큰 구조를 먼저 잡고 분할정복하는게 편하다 - AST에서 제일 최상단에 들어갈만한 놈이 뭔지를 찾고 그 아래의 Subtree를 재귀적으로 찾아가며 더이상 쪼갤 수 없으면 그때 3-Addr-Code로 바꿔보라 얘네는 이제 변수나 상수를 처리할때 팁 이다 읽어보면 당연한건데 변수나 상수를 무분별하게 꺼내면 실수할 수 있기 때문에 위와 같은 경우만 변수나 상수를 바로 꺼내는 것으로 연습을 하랜다 Storage Management § 일단 뭐 일겠지만 프로세스의 저장공간에는 Register와 Memory가 있다 Register빠르지만 용량이 작고 간접접근(주소이용해서 접근)할 수 없고 Memory는 느리지만 용량이 크고 간접접근(주소 이용해서 접근)할 수가 있다 변수를 메모리에 둘 것인지 레지스터에 둘 것인지를 1차적으로 중간언어 생성에서 하게 된댄다 방법으로는 All Memory Approach하고 Standard Approach가 있는데 All Memory Approach : 모든 변수를 Memory에 넣고 Register로 올려도 되겠다 싶은것만 올림 Standard Approach : All Memory Approach에서 레지스터로 올리는 것을 좀 규칙화하면 좋겠다고 해서 나온 것 일단 global, static은 모두 메모리에 들어가고 주소를 이용한 연산이 필요한 변수(구조체나 배열, 혹은 Scalar(일반 변수) 중에서도 주소참조 연산이 있는 경우)도 메모리에 들어감 그리고 나머지 - 주소참조 연산이 없는 Scalar은 Virtual Register에 들어간다 여기서 Virtual Register라는 것은 Register는 원래 수량이 한정되어 있고 그 수량은 아키택처에 따라 다르지만 일단 지금은 이런 제한사항을 무시하고 Register가 무한하게 있다고 생각하는 것 Memory Organization § Code는 프로그램의 코드가 저장되는 공간 - readonly면 더 빠르댄다 Static Data는 Global이나 Static같은 프로그램의 라이프타임과 수명을 같이하는 변수들이 담기는 공간 Stack은 Block Scope가 담기는 공간 - 지역변수들과 함수들이 들어감 - 알다시피 함수가 호출되면 스택에 push되고 리턴되면 pop되는 형식 여기서 중요한점은 위 그림에서 아래쪽이 주소값이 작고 위쪽이 주소값이 크다 - 스택탑의 주소가 줄어드는 것이 스택이 늘어나는 거고 주소가 커지는 방향이 스택이 줄어드는거다 Heap은 new나 Malloc처럼 동적으로 메모리를 할당받았을때 저장되는 공간 그리고 뭐 알다시피 스택과 힙이 마주보는 방향으로 되어 있어서 최대크기를 벗어나지 않고 그 안에서 둘이 융통성있게 공간을 땅따먹기하게 된다 또한 Heap의 영역은 Malloc을 했을때 OS로부터 할당받게 된다 - 컴파일러 마음대로 줄 수 있는게 아니다 이거야 뭐 알다시피 Malloc과 Free를 항상 짝으로 사용해야 하고 그렇지 않으면 예상치못한 오류가 남 - Garbage Collection을 지원하는 언어를 사용하면 이런것을 방지할 수 있더라 Code와 Static Data는 컴파일러에 의해 크기가 결정되고 Stack과 Heap은 프로세스가 진행됨에 따라 크기가 변동되더라 참고 - 윈도우에는 Windows PE라는 프로그램 포맷이 있고 리눅스에는 ELF라는 프로그램 포맷이 있는데 여기서 Windows PE에는 Mappable Sections에, ELF에는 .</description>
    <pubDate>Thu, 02 Nov 2023 15:38:05 GMT</pubDate>
  </item><item>
    <title>14. Semantic Analysis, Type Checking</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/14.-Semantic-Analysis,-Type-Checking</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/14.-Semantic-Analysis,-Type-Checking</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. Semantic Analysis § Static Semantic : 컴파일 단계에서 잡아낼 수 있는 프로그램 문맥 분석 거의 Type checking이랑 같은 의미라고 생각해도 무방하다 Dynamic Semantic : 런타임 단계에서 잡아낼 수 있는 프로그램 문맥 분석 여기서 Semantic이란 그냥 프로그램의 Construct들 (변수, 객체, 식, 문장 등) 이 올바르게 사용되었나 확인하는 것 보통 Scope적인 측면 - 변수의 접근 가능 범위와 Type적인 측면 - Declaration과 Assignment의 자료형이 맞는가를 체크하게 된다 Scope § Lifetime하고 Scope은 엄연히 다른것이다 Lifetime은 어떤 변수가 존재하는 시간 적인 개념이고 Scope은 어떤 변수에 접근할 수 있는 영역, 공간 적인 개념이다 Lexical Scope : 이건 Scope의 풀네임이라고 할 수 있는데 문자적(Textual)으로 봤을 때 어떤 변수에 접근할 수 있는 특정 범위 라고 생각하면 됨 이게 말이 어려워서 그런데 그냥 Textual이라는 것은 우리가 코드를 눈으로 봤을때 i번째줄에서 k번째 줄까지가 이 변수의 Scope 이라는 것을 알 수 있듯이 말 그대로 코드를 우리가 글읽듯이 읽었을 때 알아낼 수 있는 변수의 범위를 말하는 거다 그래서 식별자의 Scope은 그냥 그 식별자 선언을 참조할 수 있는 Lexical scope인 것 뭔말알? 참고로 C언어에서 goto는 label이 선언된 scope 내에서만 사용해야된다 - label이 딴데있으면 걸로 가면 안된다 이말이야 Symbol Table § 말그대로 식별자들에 대한 정보들을 Table의 형태로 저장하는 것이다 위처럼 식별자 이름과 분류(함수, 변수, 인자 등등), 자료형, 여러 속성들(scope지정자, 상수 등등)들을 저장하게 된다 식별자가 선언될때 저러한 정보들을 테이블에 저장해놓고 의미분석할때 이거 보면서 자료형 체크하거나 코드 생성단계에서 메모리 할당할때도 보면서 얼마나 할당해야할지 알아낸다 Hierarchical Symbol Table § 일단 Lexical Scope이 달라지면 참조할 수 있는 식별자의 범위도 당연히 달라지기 때문에 Lexical Scope마다 Symbol Table을 둘 수도 있다 하지만 대부분의 Block-structured language에서 Lexical Scope는 Nested구조, Hierarchical한 구조를 갖는 경우가 대부분이므로 Symbol Table도 이러한 구조로 만들게 된다 그래서 위 그림처럼 테이블을 구성하는거임 이러한 구조에서 식별자를 참조할때는 현재의 Scope에서 상위 Scope으로 올라가며 식별자가 존재하는지 확인하고 없다면 에러를 출력하게 한다 Implementation § 일단 AST가 만들어진 후에 Symbol Table을 만들 수 있다 AST가 Symbol Table의 선행조건인 셈 그리고 Symbol Table이 제공해야되는 기능은 식별자가 선언될때 Insert하는 기능이 있어야 할 것이고 식별자가 참조될때 Lookup - 검색하는 기능이 있어야 하것제 실제로 Symbol table을 구현할때는 위에서 본 계층구조를 그대로 본뜨지는 않는다 효율성을 위해서 다르게 함 일단 식별자의 이름은 식별자 문자열 크기가 가변적이고 관리가 힘들기 때문에 식별자 문자열만을 모아놓는 String pool을 만들어놓고 여기의 한 원소를 참조하는 포인터로 대체한다 뭐 Table한개에 대해서는 그냥 Hash table을 사용함 그리고 계층구조를 만들때에는 N-ary tree를 쓸거같지만 실제로는 Stack을 사용한다 생각해보면 Nested구조는 Stack을 통해서 구현될 수 있기 때문 뭐 옛날에 괄호쌍문제 같은거 풀때도 Stack을 이용했잖여 프로그램이 실행되는 과정에서도 block이 끝나면 그 scope에 대한 Table은 어차피 필요가 없기 때문에 전체 구조에서 유지시키는게 아니라 버리는게 더 효율적 위 그림 보면 딱 감올거임 스택에는 Hash Table이 원소로 들어가게 되고 아래 빨간글씨가 스택의 변화를 보여주고 있다 그래서 살펴보면 Scope이 열리면 그 Scope에서의 Symbol table이 Stack에 push되고 Scope이 끝나면 pop되게 됨 {int i, j; … }에서 {int x; l: …}로 코드가 진행될때 스택의 변화를 보면 어차피 두번째 scope로 가면 첫번째 scope은 참조할 수 없으니까 func f의 자식으로 두는게 아니라 버려버리는 것 Symbol Table은 코드를 한줄한줄 읽어나가며 생성되고 한번 생성된 뒤에 계속 사용하는게 아니라 분석단계에서 동적으로 생성되면서 분석하게 되는듯 그래서 위 예제에서 func f scope에서는 g는 Symbol Table에 추가되지 않은 상태인 것이다 Implementation (2) § 근데 실제로는 위와같은 방법도 안쓰고 더 최적화시킨 방법을 사용한다 Stack과 Hash map, Array를 섞어서 구현하게 됨 위 그림이 저 int x;부분에 있을 때에의 스택과 해쉬맵, 배열의 모습이다 오른쪽 아래에 각 식별자들의 hash값들이 나와있음 이걸 이제 차근차근 따라가보자고 int x, y : x의 hash값은 1이므로 hash table의 1에 array의 index 0이 들어가고 거기에 x에 대한 정보가 담긴다.</description>
    <pubDate>Thu, 02 Nov 2023 15:38:05 GMT</pubDate>
  </item><item>
    <title>15. Machine Dependent Processing</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/15.-Machine-Dependent-Processing</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/15.-Machine-Dependent-Processing</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. 컴파일러 후반부 § 컴파일러 후반부는 일단 Acritecture를 신경쓰지 않고 최적화를 하는 Machine-indepentent Optimization를 하고 그 다음부터는 Architecture에 대해 신경쓰는 Machine Dependent Processing을 하게 된다더라 Instruction Selection § Instuction Selection은 트리 형태의 Low-level IR을 보고 트리의 노드 몇개를 묶어 Machine Instruction으로 변환하는 단계이다 근데 Architecture마다 Instruction이 다르기 때문에 해당 Architecture에서 지원하는 Instruction을 활용해서 최대한 효율적인 Instruction을 선택하는 것이 중요한 것 이따가 예시 보면 알 수 있다 (from tiger book) Tree-IR § 뭐 Tiger book 이라는 곳에서 소개하는 트리 형태의 IR로 수업에서 설명을 하는데 공간에 접근하거나 공간에서 가져오기 § MEM(e) : 포인터 연산(Reference) 그냥 C언어에서 * 연산자라고 똑같이 사용하면 됨 즉, 메모리 주소에서 값을 가져오거나 메모리 주소에 값을 넣는 연산 TEMP(t) : 뭐 레지스터에 대한 Reference연산이라고 생각하면 됨 할당(Assign) § MOVE(dst, src) 오른쪽 자식을 왼쪽 자식에 넣는 명령어 그냥 C에서의 = 연산자로 바꿔서 생각하면 된다 근데 중요한 것은 Low-level IR에서는 변수나 그딴게 없기 때문에 dst에 무조건 포인터나 레지스터 연산 드가야 한다는 것이다 즉, MOVE의 왼쪽 자식은 MEM이나 TEMP가 드가야된다는 소리임 따라서 MOVE(MEM(e_dst), MEM(e_src)) 이 코드는 다음과 같다 e_dst = *e_src 근데 C언어에서도 * 연산자를 =의 왼쪽에 사용하면 그 포인터가 가르키는 곳에 넣으라는 의미가 되고(Store) 오른쪽에 사용하면 그 포인터가 가르키는 것을 가져오라는 의미(Fetch)가 되듯이 MOVE의 왼쪽 자식으로 MEM이 드가면 그 포인터가 가르키는 곳에 값을 넣는 의미가 되고 오른쪽 자식에 들어가게 되면 그 포인터가 가르키는 곳에서 값을 가져오라는 의미가 되는 것 Statement § SEQ(s1, s2)는 Statement 1을 실행하고 그 상태에서 Statement 2를 실행하라는 의미 ESEQ(s, e)는 Statement를 실행하고 그 상태에서 Expression을 계산하라는 의미 따라서 SEQ의 경우에는 결과값이 나오지 않고 상태만 바뀌지만 ESEQ는 상태가 바뀌고 그 바뀐 상태에서의 결과값이 나오는 것 Binary Operation, Const § BINOP(o, e1, e2) : e1 결과값과 e2결과값을 o에 따라서 연산하겠다는 것 헷갈리지말어라 - 세 자식중에 중간에 opcode가 드가는게 아니고 첫번째에 opcode가 드가게 된다 CONST(i) : 정수 상수 i 동치관계 § 트리가 다르게 생겨도 같은 일을 하는 동치관계가 존재하고 이걸 이용해서 더 효율적인 트리를 선택할 수 있고 이런식으로 Optimization을 하게 된다 딱 읽어보면 동치라는걸 알 수 있을거 이것도 동치인데 이건 왼쪽의 트리를 선택하는 경우가 종종 있다 - 저 레지스터에 담긴 값을 자주 써야되는 경우 트리가 좀 복잡해도 그걸 선택하기도 함 이건 조건부 동치임 왼쪽과 중간의 트리는 s를 수행함으로 변경되는 상태가 e1에 영향을 준다면 동치가 아니지만 영향을 주지 않는다면 동치가 되는 것 당연히 중간과 오른쪽은 동치이다 Instruction Selection § 그래서 이런 Low-level IR Tree에서 Node들을 모아 하나의 Instruction으로 묶게 되는데 왼쪽의 경우에는 Memory-to-Memory STORE를 지원하지 않기 때문에 MOVE와 왼쪽 자식만 묶고 오른쪽 자식은 또 따로 묶어서 Instruction을 구성했다면 오른쪽의 경우에는 Memory-to-Memory STORE를 지원해서 MOVE와 두 자식까지 묶어서 instruction을 구성하게 된 것 Memory-to-Memory STORE를 지원하면 이걸 쓰는게 더 효율적이랜다 Register Allocation § 옛날에 Low-level IR에서는 레지스터가 무한히 있다고 가정하고 레지스터를 막 가져다가 썼었는데 이제는 레지스터의 갯수가 한정되어있기 때문에 각각의 가상 레지스터를 실제 레지스터에 할당해주는 작업이 필요하고 이것은 일단 레지스터에 넣을 수 있는때까지 넣고 안되면 Memory로 내리게 된다 그래서 일단 처리속도를 최대로 하기 위해 자주 사용되는것들을 Physical register에 매핑하고 레지스터가 부족해 Memory로 내리는 것을 Spilling이라고 한다 Graph Coloring § 일단 이 문제가 지도에 색칠하는 문제와 비슷하다는 것을 이해해야됨 봐봐라 일단 Live Range라는 것을 알아야 됨 - 이건 어떤 변수가 사용되는(살아있는) 기간(범위)이라고 생각하면 된다 그래서 위의 예시의 왼쪽 코드에 대해 각각의 Live Range 를 구해본 것이 오른쪽이다 변수 a의 경우에는 0번에서 선언 되고 5번에서 마지막으로 사용되었으므로 Live range가 0~5가 되는거고 변수 b의 경우에는 2번에서 선언되고 3번에서 마지막으로 사용되니까 Live range가 2~3이 되며 변수 c의 경우에는 4번에서 선언되고 5번에서 마지막으로 사용되기 때문에 Live range가 4~5가 되는 것 실제로 컴퓨터에서 Live range를 어떻게 구하는지는 몰라도 된다 그리고 Interference라는 것은 두 변수의 Live range가 겹치는 경우에 Interference가 있다고 한다 그래서 각 변수를 Node에 적고 Interference관계를 Edge로 표현하면 하나의 그래프가 만들어지고 이 그래프에 대해 Graph coloring을 하면 되는 것이다 위 그림에서 가운데 그래프가 그거임 이제 좀 왜 레지스터 할당이 그래프 색칠문제로 변환되는지 알것제? 그래프에서 인접노드는 Live range가 겹치기 때문에 하나의 레지스터에 할당하면 안됨 따라서 인접노드에 대해서는 다른 레지스터에 할당했을때 필요한 레지스터의 갯수를 최소화시켜야만 제한된 레지스터에 최대한 많은 변수를 넣을 수 있게 되는 것 Kempe’s Algorithm § 그래프 색칠하기 문제에서 굉장히 오래되었고 그만큼 많이 쓰이는 알고리즘임 정답이 존재해도 그 정답을 도출해내지 못하는 경우가 있지만 쉽기때문에 컴파일러에서도 쓰인다 Step 1 - Simplify § 만약 색깔이 k개로 한정되어 있다면 그래프에서 k - 1개의 Edge를 갖는 노드들을 Stack에 넣어준다 그래서 과정은 다음과 같음 일단 k - 1개의 Edge를 가지는 Node들 중 하나를 Stack에 Push함 그리고 Stack에 들어간 Node와 연결된 Edge는 없다고 생각하고 다시 k - 1개의 Edge를 갖는 Node들 중 하나를 골라 Stack에 Push하는 과정을 더이상 드갈게 없을때까지 반복힌디 예시임 여기서 2개의 색으로만 칠한다 했을때 첫번째에서 Edge가 1개인 노드는 c, d, e이고 이중 하나인 c를 넣는다 그리고 c-a Edge를 제외하고 다시 Edge가 1개인 노드를 다 구해보면 a, d, e이고 이중에 하나인 e를 넣는다 b-e Edge를 제외하고 Edge가 1개인 노드는 a, d이고 이중에 a를 넣는다 a-b Edge를 제외하고 Edge가 1개인 노드는 b, d이고 이중에 b를 넣는다 Node가 하나밖에 안남았으므로 Step 1이 종료됨 Step 2 - Coloring § 남아있는 노드를 칠하고 스택에서 하나씩 꺼내면서 인접한 노드와 다른색깔로 칠해주면 됨 위 그림 보면 알 수 있을거임 - Stack에서 하나씩 꺼내면서 색깔을 칠해준다 Spilling § 위에서도 말했듯이 Kempe’s Algorithm을 사용하면 해가 있음에도 해결하지 못하는 경우가 생기긴 한다 이거 보면 d를 Stack에 넣은 뒤에 모든 Node의 Edge가 2개이기 때문에 더이상 진행하지 못하지만 위 그림처럼 정답이 존재한다 - 뭐 이런 해를 구하지 못하는 경우에는 어케하는지 설명 안했으니까 고민하지마셈 그리고 위처럼 해가 아예 없는 경우도 있음 이럴때는 레지스터에 넣지 않고 메모리로 내리는 Spilling을 진행한다 Spilling을 할때는 새로운 Live range가 아주 짧은 새로운 Virtual Register를 도입해 명령을 재작성하는데 과정은 다음과 같음 일단 어떤 Virtual Register를 Spilling할건지 정함 그리고 해당 Virtual Register를 메모리의 한 공간과 연결한다 해당 Virtual Register가 등장하는 부분 바로 위에 할당된 메모리 공간에 있던 값을 임시 레지스터로 옮기는 코드를 추가하고 임시 레지스터를 이용해 Instruction을 수행하도록 코드를 바꾼다 예시를 보면 좀 더 이해가 될거임 일단 t2를 Spilling하기로 정했고 t2를 메모리의(Stack frame의) 한 공간인 [ebp - 24] 와 연결해줌 그리고 임시 레지스터인 t35를 도입해 t2를 사용하는 Instruction직전에 mov t35, [ebp - 24]를 한다 마지막으로 t2대신 t35를 Instruction에서 사용하도록 바꿔줌 Interference나는 Virtual register를 해결하기 위해 또 다른 Virtaul Register를 도입하는게 약간 이상하지만 보면 이렇게 새로 도입한 Virtual Register는 Live range가 한두줄밖에 안되기 때문에 아주 짧음 - 이렇게 바꾸고 Kempe’s Algorithm으로 색칠해보면 Interference가 거의 나지 않는다 Instruction Scheduling § 일단 이것을 해야하는 이유는 어떤 Instruction이 끝나야 다음 Instruction이 실행되야 하는 경우가 아니라면 두개의 Instruction을 1사이클 차이로 실행시킬 수 있기 때문 따라서 어떤 Instruction을 실행시키기 위해 앞선 Instruction이 종료되는 것을 기다리느라 CPU 가 놀고있는 걸 Stall이라고 하는데 이러한 Stall 등의 비효율을 줄이기 위해 Instruction을 재배치 하는 것을 Instruction Scheduling이라고 함 그래서 위의 예시를 보면 1, 5, 9, 13사이클에서 실행되는 LOAD의 경우 Dependency가 없기 때문에 바로 실행이 가능한데 중간중간에 Dependency가 있는 Instruction이 포함되어 있어 그만큼 지연되는 것을 볼 수 있음 따라서 왼쪽처럼 Dependency가 없는 몇개의 Instruction을 처음에 다 돌려놓음으로 Stall을 줄일 수 있더라 Chanllenges § 근데 당연하게도 이건 쉬운일이 아님 일단 당연하게도 동일한 동작을 하는 코드로 바꿔야 되고 최적화하는 것이기 때문에 Wasting time을 줄여서 최종적으로 걸리는 시간이 줄어야 하고 Register Spilling을 되도록이면 피해야 함 - Memory 접근은 비용이 큰 연산이기 때문 Instruction을 옮겼을때 use-def의 길이가 길어져서 Life range가 늘어날 수 있기 때문에 Interference가 일어날 확률이 늘어남 - 이러한 위험부담을 항상 고려해야 한다 Scheduling의 종류 § Static Scheduling : 컴파일 타임에 스케줄링하는 것 Local Basic Scheduling : 반복문이나 분기문이 없는 하나의 Block 내에서 스케줄링하는 것 Loop Scheduling : 반복문이 들어간 상황에서 스케줄링하는 것 Global Scheduling : 전체적으로 스케줄링하는 것 Dynamic Scheduling : 런타임에 스케줄링하는 것 List Scheduling § Local Basic Scheduling의 하나로 Instruction을 Heuristic을 이용해 Greedy하게 선택하는 방법 간단하게 설명하면 Dependency Graph(Precedence Graph)를 만들고 Topological sorting을 하되 선행노드가 없는애들중에 하나를 고를때는 Heuristic을 기준으로 Greedy하게 선택하는 방법 Dependency Graph(Precedence Graph) 만들기 § 뭐 이거 그리는건 어렵지 않음 그냥 의존관계 고려해서 그려주면 된다 Heuristic Priority 산출 § List Scheduling을 할 때는 Latency를 Heuristic으로 둔다 이걸 어떻게 구하냐면 맨 마지막 Instruction부터 시작해 위로 올라가면서 각 Instruction에 걸리는 시간을 누적해주면 됨 위 예시를 보면서 해보자고 일단 마지막인 i를 할때는 이놈이 3이 걸리다고 가정했을때 Latency는 3이 됨 그리고 그 위의 h의 경우에는 이놈이 2가 걸린다고 가정하면 이놈을 하고 i까지 하려면 2 + 3으로 5이 걸린다 - 이게 Latency가 되는 것 g의 경우에 3이 걸리고, f의 경우에 2가 걸린다면 각각의 경우에 i까지 마무으리하려면 h의 Latency인 5에다가 2, 3을 각각 누적해 f의 경우에는 7이 되고 g의 경우에는 8이 되는 것 이런식으로 Precedence Graph의 모든 노드에 대해 Latency를 기준으로 Heuristic을 구해준다 Ready-operation Priority Queue만들어서 진행 § 그래서 이제 바로 실행 가능한 Instruction들을 Heuristic을 기준으로 하는 Priority Queue에 넣고(얘를 Ready-operation Priority Queue라고 하드라) 하나씩 빼면서 정렬해주면 되는 것 위 예시를 보면 일단 {a, c, e, g}가 들어가게 될거임 제일 우선순위가 높은놈 고르면 당연히 a가 골라지겠지 그럼 그놈을 지우고 바로 실행 가능해진놈을 큐에 넣음 - b가 들어가고 {c, e, b, g}가 된다 - 우선순위가 같을때는 뭐가 먼저 오든 상관없음 그리고 c가 top에 있으니까 c을 빼고 실행가능해진놈을 넣음 - 아무것도 없으니까 바로 다음으로 진행 그 다음은 e가 top에 있으니까 e를 빼고 실행하능해진놈을 넣음 - 이번에도 실행가능해진놈은 아무것도 없음 이런식으로 계속 진행해서 Topological sorting을 하게 된다 기타 Optimization § Optimization에는 Scheduling말고 딴게 더 있는데 Architecture에서 지원해주는 다양한 기능을 이용한다던지 뭐 예를들면 1 더하는 기능을 inc라는 걸로 지원해서 1더할때는 add를 사용하는것보다 inc를 사용하는 것이 더 좋다거나 - 특수목적의 명령어 jump address만을 위한 레지스터를 제공한다거나 - 특수목적의 레지스터 아니면 Register간 mov를 줄일수도 있다 레지스터간 mov는 어차피 같은값을 가지니까 기존의 레지스터를 계속 사용하는 식으로 mov를 제거 근데 이건 Live range가 늘어날 가능성이 있으므로 주의해야된다 아니면 중복된 LOAD를 제거할 수도 있음 뭐 위처럼 store을 한 다음에는 r1에 여전히 x의 값이 남아있기 때문에 굳이 다시 load해주지 않고 바로 사용할 수 있다 .</description>
    <pubDate>Thu, 02 Nov 2023 15:38:05 GMT</pubDate>
  </item><item>
    <title>16. Analysis &amp; Optimization</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/16.-Analysis-&-Optimization</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/16.-Analysis-&-Optimization</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. Analysis &amp; Optimization § 최적화(Optimization) 은 동등한 동작을 수행하되 실행시간이 짧거나 저장공간을 적게 먹는 코드로 바꾸는 것을 의미함 최적화는 당연히 Instruction의 수를 줄이거나 Cycle이 더 적은 Instruction을 사용하는 방법으로 진행되는데 최적화에서 가장 중요한 것이 최적화 이후에도 동일하게 동작해야 하는것 이기 때문에 분석(Analysis) 을 통해 동일하게 동작하는지를 확인하게 된다 Control Flow § Control Flow는 프로그램이 수행되는 순서를 말하는건데 그냥 Program Counter가 1씩 증가하며 Instruction이 쭉 실행되는 경우에는 별로 분석할게 없다 중요한건 분기(Branch) 로 프로그램의 다른 부분으로 점프하는 흐름에 관한 것이 Control Flow 인 것 Dynamic Control Flow 는 Input값이 주어진 상태에서의 프로그램 실행 순서라고 생각하면 된다 Input값을 알기 때문에 어디로 분기할지 알 수 있고, Control Flow를 보다 정확하게 예측할 수 있음 Input값이 다르게 들어오면 다르게 실행되므로 Dynamic이 붙는 것 Static Control Flow는 Input 값을 모르는 상태에서의 프로그램 실행 순서를 말하는거다 따라서 Input을 모르기 때문에 정확한 예측은 불가능하고 Worst Case를 생각해서 예측하게 된댄다 컴파일 단계에 하게 된다는 듯 Static Property, CFA § 일단 Static Property는 프로그램 분기 방향과 무관하게 도출되는 성질을 의미한다 그리고 CFA(Control Flow Analysis) 는 먼저 CFG(Control Flow Graph) 라는 것을 만든다 이건 프로그램이 어떻게 분기될 수 있는지의 경우의 수를 그래프 형태로 나타낸 것 그리고 이걸 만든 후에 Static Property를 도출하고 코드를 최적화 하는 것이 목적인 분석이다 Basic Block(BB) § Basic Block(BB) 는 분기 없이 한번에 쭉 실행되는 Instruction 모음이라고 생각하면 됨 뭐 동일한 실행 조건(Execution Condition) 을 적용받는 Instruction 모음이라고도 표현하는데 이말은 BB의 첫번째 Instruction이 실행된다면 마지막까지 무조건 실행된다는 뜻이다 따라서 다음의 조건을 만족하는 Instruction 묶음을 BB라고 한다 일단 BB의 시작은 무조건 첫번째 Instruction이다 - 다른곳에서 분기되어 들어와 BB의 중간에서 갑자기 실행되면 안됨 그리고 BB의 끝은 무조건 마지막 Instruction이고 이거 외에는 분기가 없다 - 말그대로 BB의 중간에서 갑자기 다른데로 분기하면 안됨 BB를 구하는 방법은 간단하다 우선 Leader를 구해야 됨 - 이건 BB의 첫번째 Instruction을 의미하는 거임 Leader를 구하는 방법도 간단함 프로그램의 시작 Instruction은 무조건 Leader겠제 그리고 분기해서 도착하는 Instruction도 Leader가 된다 - 분기해서 도착했으니까 거기서부터 시작이 되겠지 마지막으로 분기문의 바로 아래에 있는 Instruction도 Leader이다 왜냐하면 이전의 기억을 더듬어보면 특정한 조건일때 분기하고 그 조건에 안맞으면 그냥 다음 Instruction이 실행되게 하는 방식으로 두 갈래를 나누기 때문 이렇게 Leader를 다 구하고 한 Leader에 대해 다음 Leader이전까지의 부분이 하나의 BB가 되는 것 위 예시에서 보면 일단 L1이 프로그램의 시작지점이니까 Leader가 되고 L2하고 L10이 분기되어 도착하는 곳이니까 이곳도 Leader가 된다 또한 분기문의 직후인 L4, L7, L8도 Leader임 따라서 BB를 묶어보면 L1-L1, L2-L3, L4-L6, L7-L7, L8-L9, L10-L11이 됨 Control Flow Graph(CFG) § BB를 노드로 하고 그것들의 실행 순서를 화살표 Edge로 연결한 그래프를 일컫는 말임 모든 BB가 노드가 되고 여기에 시작지점과 끝나는 지점을 나타내는 가상의 노드인 Entry Node와 Exit Node를 붙인다 당연히 가상의 노드이기 때문에 프로그램상에는 표현되지 않음 위의 예시 BB대로 그린 CFG의 예시임 물론 여기에는 Entry Node와 Exit Node가 표현되어있지 않지만 그냥 보통 그런 Node들을 붙인다는거지 무조건 붙여야되는건 아니다 일단 무조건 분기하는 부분이 없으니까 모든 BB들을 다 이어주고 L3에서 L10으로 분기하니까 L3가 속한 BB2에서 L10이 속한 BB6으로 Edge가 연결된다 마찬가지로 L6에서 L2로 분기하니까 BB3에서 BB2로 Edge가 연결되어있고 L7에서 L10으로 분기하니까 BB4에서 BB6으로 Edge가 연결되어 있는 것 Weighted CFG § Profiling이라는 것이 있는데 얘는 프로그램을 몇번 돌려보고 여러가지 통계를 내는 것이다 Edge Profile : 각 Edge들을 몇번 지나치는지 Block Profile : 각 BB들을 몇번 지나치는지 Path Profile : Edge들과 BB들로 구성된 CFG의 일부분을 몇번이나 지나치는지 그래서 이런 다양한 Profile들을 그래프에 같이 적은게 Weighted CFG이다 보통 최적화를 하다 보면 분기하는 상황에서 한쪽을 최적화하면 다른 한쪽이 안좋아지는 Trade-off가 일어나기도 하는데 이때 빈도수에 따라서 Optimize하면 더 좋겠제 Optimization § Acyclic Code Optimization § 반복문이 없는 코드에서의 최적화 하나의 BB내에서 최적화 하는 Inner Basic Block Optimization하고 BB간의 관계를 보며 넘나들며 최적화 하는 것을 Inter Basic Block Optimization이 있다 Inner Basic Block Optimization § 1.</description>
    <pubDate>Thu, 02 Nov 2023 15:38:05 GMT</pubDate>
  </item><item>
    <title>2. 어휘분석기 만들어보기</title>
    <link>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/2.-%EC%96%B4%ED%9C%98%EB%B6%84%EC%84%9D%EA%B8%B0-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EA%B8%B0</link>
    <guid>https://mdg.haeramk.im/compiler.fall.2021.cse.cnu.ac.kr/2.-%EC%96%B4%ED%9C%98%EB%B6%84%EC%84%9D%EA%B8%B0-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EA%B8%B0</guid>
    <description> 충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 부적절한 언행 이 포함되어 있을 수 있습니다. C언어(와 비슷한거) 만들기 § Symbol § FSA § 읽어보면 이해되제? Domain § 이것도 알겟제 enum 써봤는데 상수 여러개를 한번에 정의할때 쓰면 좋더라 구현 § 일단 while(isspace())로 공백을 다 지움 그리고 superLetter()로 superLetter인지 확인하는데 이름이 superLetter인 이유는 식별자에 ‘_’ 도 올 수 있기 때문 superLetter인 경우에는 식별자나 키워드이므로 뒤이어 나오는 superLetter를 do-while문으로 다 받는다 그리고 ID_LENGTH보다 i가 크거나 같을 경우에는 입력된 것이 식별자나 키워드의 최대 크기인 ID_LENGTH보다 크다는 뜻이므로 구문 에러를 발생시킨다 정상인 경우에는 문자 배열에 널문자를 넣어 문자열을 완성시켜주고 마지막으로 입력받은 superLetter나 숫자가 아닌값은 ungetc()를 통해 다시 버퍼에 넣어줘 안읽은척 해준다 그 이후에는 keyword배열을 훑으며 입력된 것이 keyword 테이블에 존재하는지 확인하고 존재한다면 for문을 빠져나오게 해준다 만약 index가 NO_KEYWORD보다 작으면 keyword테이블에 존재한다는 뜻이므로 반환할 토큰의 토큰 번호를 index에 맞는 키워드의 토큰 번호로 채워준다 하지만 그렇지 않다면 식별자로 처리하기 위해 토큰 번호를 식별자의 토큰 번호로 설정해주고 토큰의 값에 입력된 것을 넣어준다 그리고 공백 이후 나오는 첫 문자가 superLetter가 아니고 숫자일 경우에는 정수로 처리하기 위해 반환할 토큰의 토큰번호를 tnumber로 해주고 토큰 값으로 문자를 정수로 바꿔 넣어준다 마지막으로 식별자, 키워드, 숫자도 아닐 경우에는 연산자이기 때문에 switch case문으로 어떤 연산자인지 알아내 토큰을 생성하게 된다 token.</description>
    <pubDate>Thu, 02 Nov 2023 15:38:05 GMT</pubDate>
  </item>
    </channel>
  </rss>