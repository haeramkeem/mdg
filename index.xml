<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>Madison Digital Garden</title>
      <link>https://mdg.haeramk.im</link>
      <description>Last 10 notes on Madison Digital Garden</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>매디쏜 디지딸 갈든</title>
    <link>https://mdg.haeramk.im/</link>
    <guid>https://mdg.haeramk.im/</guid>
    <description> 오리지날 씨리즈 § &quot;오리지날 씨리즈&quot; 는 Networked-thought 에 포함되지 않는, 강의 필기록과 같은 Sequential 한 문서를 모아놓는 항목입니다. (이화여대) 운영체제 강의록 (충남대) 운영체제 강의록 .</description>
    <pubDate>Tue, 31 Oct 2023 16:26:49 GMT</pubDate>
  </item><item>
    <title>(이화여대) 운영체제 강의록</title>
    <link>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/(%EC%9D%B4%ED%99%94%EC%97%AC%EB%8C%80)-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%95%EC%9D%98%EB%A1%9D</link>
    <guid>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/(%EC%9D%B4%ED%99%94%EC%97%AC%EB%8C%80)-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%95%EC%9D%98%EB%A1%9D</guid>
    <description>Table of Contents § 1. 운영체제란 2. System Structure &amp; Process Execution 3. Process 4. Process Management 5. CPU Scheduling 6. Process Synchronize 7. Deadlocks 8-1.</description>
    <pubDate>Tue, 31 Oct 2023 16:26:49 GMT</pubDate>
  </item><item>
    <title>1. 운영체제란</title>
    <link>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/1.-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%9E%80</link>
    <guid>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/1.-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%9E%80</guid>
    <description>운영체제 핵심 § 운영체제의 핵심은 컴퓨터의 하드웨어 바로 위에 설치되어 아래로는 하드웨어 자원을 관리하고 위로는 사용자 혹은 사용자 애플리케이션을 위한 편의 기능을 제공하는 것이다. 그래서 그 편의기능이 뭐냐 사용자로 하여금 내가 실행시킨 프로그램만 실행되고 있게 느끼도록 해주고 하드웨어를 제어하는 복잡한 작업을 대행하기 때문에 하드웨어에 대한 부분은 사용자가 고려하지 않아도 되게끔 해준다.</description>
    <pubDate>Tue, 31 Oct 2023 16:26:49 GMT</pubDate>
  </item><item>
    <title>10. File Systems</title>
    <link>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/10.-File-Systems</link>
    <guid>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/10.-File-Systems</guid>
    <description>File 이란? § 이름을 통해 접근할 수 있는 정보들의 집합 을 File 이라고 하더라 일반적으로 너가 아는 것들 이외에도 Linux 에서는 다양한 장치들도 File 로써 관리된다 → 표준입출력이나 디스크들도 Linux 에서는 파일로 관리된다 그리고 당연히 디스크같은 비휘발성 저장장치에 저장된다 File Operation § Create, Delete Open, Close 파일의 Metadata 를 메모리에 적재하는 것을 Open 메모리에서 내려 다시 디스크에 저장하는 것은 Close 라고 한다.</description>
    <pubDate>Tue, 31 Oct 2023 16:26:49 GMT</pubDate>
  </item><item>
    <title>11. Disk Scheduling</title>
    <link>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/11.-Disk-Scheduling</link>
    <guid>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/11.-Disk-Scheduling</guid>
    <description>용어정리 § Sector, Block § Sector: 디스크에서 정보가 저장되는 가장 작은 단위 하나의 섹터는 Header + Data (512byte) + Trailer 이렇게 세 부분으로 구성되고 Header 와 Trailer 에 섹터 번호하고 ECC(Error Correcting Code) 가 저장된다 Header 와 Trailer 에 드가는 정보는 Disk Controller 가 직접 접근하고 운영하는데 만약 실제 데이터와 ECC 가 호환되지 않는다면 Bad Sector 로 간주하고 그에 따른 대응을 하게 된다 Block: 디스크 외부에서 바라봤을 때의 데이터 저장 단위 이게 약간 헷갈릴 수도 있는데 Block 들이 디스크 내의 각 Sector 에 매핑되는 식으로 저장된다고 생각하면 됨 그리고 Block 은 1차원 배열의 형태를 띈다 → Sector 의 경우에는 몇번째 원판의 몇번째 섹터 이렇게 2차원 배열로 생각할 수 있다면 Block 은 이런 물리적인 구분 없이 그냥 쭉 이어서 1차원 배열의 형태를 띈다는 것 → 뭔가 아닌거같기도 하고 확실하지 않음 위와 같은 차이점때문에 섹터와 블럭의 사이즈는 같지 않을 수도 있는듯 디스크의 구조 § Platter: 디스크를 구성하는 각 원판 Track: Platter 내에서 같은 반지름을 가지는 Sector 의 집합 Cylinder 는 원래 여러 Platter 에 걸친 Track 들을 가상의 원통으로 묶은 것을 의미하는데 뭐 Track 이랑 비슷하게 생각해도 된다 Arm: 디스크를 읽어들이기 위한 막대 Read-write Head: Arm 에서 실제로 데이터를 읽어들이는 부분 Spindle: 디스크를 회전시키는 축 Formatting § Physical Formatting (Low-level Formatting): 디스크에 섹터들을 나누는 과정 Logical Formatting: FAT 같은 파일 시스템을 디스크에 구성하는 과정 Partitioning, Booting § Partitioning: 하나의 물리 디스크를 여러개의 논리 디스크로 나누는 과정 Booting: 컴퓨터를 초기화하는 과정 부팅은 다음과 같은 순서대로 일어난다 ROM 에서 Small Bootstrap Loader 를 실행시킨다 메모리는 기본적으로 휘발성이지만 비휘발성의 아주 작은 공간인 ROM 이 존재한다 CPU 는 메모리에밖에 접근할 수 없기 때문에 ROM 에 있는 부트로더를 실행함 이놈은 Small Bootstrap Loader 라고 불리는데 이건 부팅을 시작하기 위한 기본적인 코드인 디스크에서 부트로더 전체를 메모리에 올리도록 하는 코드가 들어있다 Sector 0 에서 Full Bootstrap Loader 를 가져와서 실행 위에서 SBL 이 부트로더 전체를 메모리에 올리는 역할을 한다고 했자네 이때의 부트로더를 Full Bootstrap Loader 라고 하고 이것은 Sector 0에 저장되어 있다 Sector 0은 디스크에서 가장 최외각 트랙의 첫번째 섹터로 무적권 FBL 가 저장되도록 예약되어 있다 Disk Access Time § 디스크에서 데이터를 읽어오는 과정은 아래와 같이 세 부분으로 나눌 수 있다 Seek Time: 디스크의 암(헤드)을 데이터가 위치한 실린더로 움직이는데 걸리는 시간 Rotational Latency: 암이 제대로 위치한 뒤에 디스크가 회전해 원하는 섹터가 헤더 위로 회전해오는데 걸리는 시간 Transfer Time: 실제 데이터의 전송 시간 Disk Bandwidth: 단위 시간동안 전송된 바이트의 수 디스크에서 데이터를 읽어올 때 가장 오래 걸리는 것은 Seek Time 이고 Disk Bandwidth 를 극대화 하기 위해 섹터를 읽는 순서를 최적화하는 작업을 Disk Scheduling 이라고 한다 Disk Scheduling § Disk Bandwidth 를 최대화 하기 위해서는 Seek Time 을 최소화 해야 한다고 했으므로 요청된 섹터들의 트랙 (실린더)를 기준으로 어떤 섹터를 먼저 읽을 지 결정한다 FCFS (First Come First Service) § 딱히 뭐 설명할 것도 없다 그냥 무지성 선입선출 당연히 비효율적이어서 안쓴다 SSTF (Shortest Seek Time First) § 이건 현재 헤드의 위치를 기준으로 가장 가까운 놈부터 처리하는 방식인데 예상하듯이 Starvation 문제가 발생한다 → 한곳에 요청이 몰리면 그와는 멀리 있는 요청은 계속 순위가 밀리기 때문 SCAN (+ C-SCAN, N-SCAN) § SCAN 은 기본적으로 다음과 같이 작동한다 헤드가 디스크의 끝(최외각 혹은 최내각) 트랙으로 움직인다 헤드가 반대쪽 끝으로 움직이면서 경로 상에 있는 요청들을 처리한다 2번 과정을 반복한다 따라서 가장 기본이 되는 SCAN 은 아래 그림 한장으로 설명된다 보면 약간 엘리베이터와 비슷하기 때문에 엘리베이터 스케줄링이라고도 부른다 이 방식은 Seek Distance 로 최적화 할 수 있고 Starvation 도 안생기는 장점이 있지만 트랙의 위치에 따라 대기시간이 고르지 않다는 문제가 있다 헤드가 한번 끝에서 끝까지 움직이는데 10초의 시간이 걸린다 하면 가운데 트랙의 경우에는 가장 오래 걸려도 헤드가 절반을 움직이고 또 절반을 되돌아오면 되기 때문에 10초가 걸리지만 외곽에 있는 트랙의 경우에는 헤드가 한번 쭉 움직이고 또 반대방향으로 쭉 되돌아와야 하기 때문에 최대 20초가 걸릴 수 있다 위와 같은 문제를 해결하기 위한 SCAN 의 변형이 C-SCAN 이다 헤드가 디스크의 끝(최외각 혹은 최내각) 트랙으로 움직인다 헤드가 반대쪽 끝으로 움직이면서 경로 상에 있는 요청들을 처리한다 위 과정을 반복한다 보면 그냥 SCAN 과의 차이점은 3번 과정인데 그냥 SCAN 의 경우에는 양방향에 대해 경로상의 요청을 처리하지만 C-SCAN 의 경우에는 단방향에 대해 요청을 처리한다 → 즉, 한쪽 방향으로 움직일 때만 요청을 처리하고 반대방향으로 되돌아 갈 때는 요청을 처리하지 않고 그냥 움직인다는 것 따라서 아래의 그림으로 한장 정리가 가능하다 따라서 이 방법을 사용하면 기존의 SCAN 방식에 있던 대기시간 불균형을 해소할 수 있다 SCAN 방식의 변형 중에는 N-SCAN 이라는 놈도 있는데 얘는 SCAN 과 유사하지만 이동중에 들어온 요청에 대해서는 경로상에 있어도 처리하지 않는다는 차이점이 있다 즉, 한 방향으로 이동하기 전에 들어온 요청에 대해서만 이동하면서 처리하고 이동하는 중간에 들어온 요청은 지금 처리하지 않고 다시 반대방향으로 되돌아갈 때 처리한다는 입장임 LOOK (+ C-LOOK) § 위그림은 C-LOOK 이다 SCAN 과 LOOK 의 차이점은 헤드가 어디까지 움직이냐에 달려 있다 SCAN 의 경우에는 무조건 최외각-최내각에서 방향 전환을 하는 반면 LOOK 의 경우에는 해당 방향에 더 이상 요청이 없으면 방향 전환을 한다 즉, 트랙이 199까지 있을 때 요청된 트랙의 가장 큰 값이 180이면 SCAN 은 (오름차순일 때) 180 을 들르고 199를 간 다음에 내려가는 반면 LOOK 의 경우에는 180 을 들른 다음에 바로 내려간다 SCAN 과 C-SCAN 의 차이와 동일하게 LOOK 과 C-LOOK 은 양방향이냐 단방향이냐의 차이밖에 없다 Disk Scheduling Algorithm 의 특징 § 일단 보통 SCAN 이나 LOOK 계열의 스케줄링 방식을 사용하고 그리고 필요한 경우 쉽게 교체될 수 있도록 OS 와 별도의 모듈로 내장된다고 한다 실제 Disk Bandwidth 는 이러한 알고리즘적 측면 외에도 파일을 어떤 방식으로 저장할지도 큰 영향을 끼친다고 한다 (연속 할당? 분할 할당?) Swap Area Management § 일단 디스크를 사용하는 이유를 보면 메모리의 경우에는 휘발성이기 때문에 비휘발성의 데이터 저장 장치가 필요했고 메모리보다 저렴하되 메모리의 역할을 보조해줄 수 있는 저장장치가 필요하기 때문이다 위 이유 중 두번째를 위한 것이 앞에서도 계속 나온 Swap Area 인데 어떻게 관리되는지 대강 알아보면 뭐 요즘 우분투는 그냥 파티션 안쓰고 파일시스템으로 스왑영역을 관리하지만 디스크를 파티션해서 Swap Area 를 지정해 주는 것이 많이 쓰였다고 하더라 일반적인 파일 시스템과 Swap Area 의 차이점은 일단 파일보다 훨씬 더 빈번하게 참조되고 메모리를 대체하는 공간이기 때문에 데이터들이 임시적이다 → 잠깐 머물렀다가 프로세스가 종료되면 사라지기 때문 따라서 공간 효율성보다는 속도 효율성이 훨씬 중요하고 일반적으로 데이터를 나눠 저장하는 것이 아닌 한 덩어리로 저장 (Sequential Allocation) 하게 되고 블럭의 크기도 512바이트가 아닌 512Kb 등의 훨씬 큰 사이즈를 갖게 된다 RAID § RAID (Redundant Array of Independant Disks): 는 디스크 여러개를 묶어서 고가용성과 속도 등의 이점을 얻고자 하는 방법이다 Interleaving, Striping (분산 저장): 여러개의 디스크에서 데이터를 부분적으로 병렬적으로 읽어옴으로써 속도를 향상시키는 방법 Mirroring, Shadowing (중복 저장): 여러개의 디스크에 데이터를 중복해서 저장해서 Disk Failure 등의 문제 상황을 방지하는 방법 단순히 중복해서 저장하는 것만이 아니고 Parity (에러 탐지 코드) 도 추가적으로 구성하기도 한다 .</description>
    <pubDate>Tue, 31 Oct 2023 16:26:49 GMT</pubDate>
  </item><item>
    <title>2. System Structure &amp; Process Execution</title>
    <link>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/2.-System-Structure-&-Process-Execution</link>
    <guid>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/2.-System-Structure-&-Process-Execution</guid>
    <description>System Structure § CPU + Memory = Computer 나머지 디스크 키보드 등은 IO Device 라 부른다. Memory 는 CPU 의 작업공간이라 할 수 있음 → Instruction들을 하나씩 메모리에서 읽어다 실행시키게 됨 → PC가 메모리의 주소를 가리키기 때문 CPU의 유일한 업무는 PC가 가리키는 Instruction을 가져와서 실행시키는 것 밖에는 없다.</description>
    <pubDate>Tue, 31 Oct 2023 16:26:49 GMT</pubDate>
  </item><item>
    <title>3. Process</title>
    <link>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/3.-Process</link>
    <guid>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/3.-Process</guid>
    <description>Process and Context § 일단 뭐 프로세스는 Program in Execution 을 의미한다. 여기서 이제 프로세스의 문맥(Context) 가 중요한데 이건 특정 프로세스가 어느 한 시점에 어떤 상태인지를 나타내는 정보라고 생각하면 된다 다음과 같이 세개로 분류해볼 수 있다 CPU 상태( → 레지스터 상태): PC 나 다른 레지스터에 어떤 값이 들어와있었나 MEM 상태: Code 부분에는 어떤 것들이 담겨있고 Data의 변수들에는 어떤 값이 들어있고 Stack에는 어떤 함수 호출이 쌓여있는지 등등 Kernel 상태: 프로세스를 제어하기 위한 정보인 PCB에 어떤 값이 들어가있는지 혹은 해당 프로세스가 어떤 Syscall 을 호출해서 어떤 커널 함수들이 Kernel stack에 쌓여있는지 프로세스의 상태 관리가 필요한 이유는 Context switching 때문이다 → Time sharing등을 위해 실행중인 프로세스를 바꾸려면 실행중이던 프로세스의 상태를 완전히 백업하여 백업된 Context 를 다시 불러왔을 때 이전에 실행중이던 상태 그대로 재개되어야 하기 때문시 5 State Process Model § 우리 빵효경 교수님은 5 State Process Model 로 설명을 한다 5가지 상태중에 중요한건 가운데에 3가지인 Running, Ready, Waiting(Blocked) 인데 Running 은 CPU를 할당받아 한창 실행이 되고 있는 상태고 위 그림에서 보이는것처럼 Running 상태가 끝나는건 3가지 경우가 있다 타이머 종료 프로그램 종료 (Exit) 이벤트 발생 → 자발적 CPU 반납 Ready 는 다른건 다 준비됐고 CPU만 할당받으면 다시 실행할 수 있는 상태를 의미한다 얘는 위 그림에서 보이는것처럼 프로세스가 생성되어 CPU만 받으면 되는 상태까지 오거나 Running 상태였다가 Timer 가 끝나서 CPU를 뺏겼거나 Block 을 먹었다가 Event 가 종료되어 다시 준비완료 그리고 Blocked 는 Syscall 등의 이벤트에 의해 지금 당장 CPU를 할당해주어도 실행할 수 없는 상태를 의미한다 여기서 이벤트는 IO 같은 Syscall 혹은 Interrupt 일 수도 있지만 조리퐁같은 경우에도 이벤트가 된다 → 다른 쓰레드가 이미 공유 데이터를 쓰고있어서 현재 프로세스가 접근할 수 없는 경우에도 이벤트라고 말할 수 있다 PCB (Process Control Block) § 앞에서도 누누이 말했듯 커널에 저장되어 프로세스를 제어하기 위한 정보가 PCB (Process Control Block) 이고 4개정도의 파트로 이루어진다 OS 관련 정보에는 (1) 프로세스의 상태 (2) PID (3) 스케줄링 정보와 (4) 우선순위 정보가 드가고 CPU 관련 정보에는 PC를 포함한 레지스터의 값들 MEM 관련 정보에는 해당 프로세스의 Code, Data, Stack 의 위치 (메모리 주소) 정보 File 관련 정보에는 이놈이 열어놓은 파일 디스크립터들이 드간다.</description>
    <pubDate>Tue, 31 Oct 2023 16:26:49 GMT</pubDate>
  </item><item>
    <title>4. Process Management</title>
    <link>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/4.-Process-Management</link>
    <guid>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/4.-Process-Management</guid>
    <description>Process Lifecycle § Process Creation § 프로세스는 (Init process 가 아니라면)부모프로세스가 반드시 존재하고, 부모 프로세스를 복제하는 방식으로 자식 프로세스가 생성된다 뭐 init process 는 알다시피 sysvinit 이나 systemd 등이 있겠제 따라서 프로세스는 init process 를 루트로 하는 트리형식의 계층 구조를 형성하게 된다 이렇게 자식을 복제하는 것은 fork() 시스템 콜을 이용해 수행할 수 있다 프로세스 생성이 시스템 콜인 이유는 사용자 프로세스가 직접 하기에는 어려운 작업이고 아마 보안상의 문제도 껴있을거다 자식 프로세스도 당연히 프로세스니까 자원을 할당받을텐데 여기에는 몇가지 정책(모델) 이 존재한다 자원을 부모와 공유하여 운영체제로부터 받지 않는 모델 자원을 부모와 일부만 공유하고 나머지는 운영체제로부터 할당받는 모델 부모와 공유하지 않고 전부 운영체제로부터 할당받는 모델 생각해보면 자식 프로세스는 부모 프로세스와 독립적인 프로세스이기 때문에 자원을 공유하지 않고 운영체제로부터 할당받는게 맞는 거 같지만 UNIX 같은 경우에는 효율성을 위해 일단 부모와 공유하는 방식을 사용한다 뭔소리냐면 fork() 과정에서 부모꺼를 복제한다고 했자네 근데 자원을 복제하면 결국에는 똑같은게 두개가 생길거 아님 → 뭐 프로세스의 Data, Code, Stack 같은게 똑같은게 두개가 생기게 될거아님 이게 좀 낭비같은거야 그래서 UNIX 에서는 일단 자원을 복사하지 않고 공유하고 있다가 부모랑 달라지면 그때 복사를 하는 방식을 이용한다 즉 Lazy copy 라고 말할 수 있는거임 → 이걸 Copy-On-Write (COW) 라고 표현한다 복제하는 과정을 좀 더 자세히 살펴보면 일단 fork() 가 불려지면 운영체제는 PID 를 제외한 부모의 모든 것(뭐 PCB나 바이너리 같은것들 → 앞에서 배운 Process context 에서 PID 만 뺀거라고 생각해도 된다)을 복사한다 그리고 자식 프로세스에게 새로운 주속 공간을 할당한다 하지만 fork() 만 존재한다면 모든 프로세스가 부모랑 같은 작업만 할거 아니냐 → 그래서 (일반적으로는) fork() 이후에 exec() 이라는 시스템 콜이 사용된다 exec() 은 기존에 존재하던 프로세스에 새로운 프로그램을 덮어 씌우는 시스템 콜인데 일반적으로 fork() 이후에 exec() 시스템 콜이 호출되는 식으로 프로그램이 프로세스로 변환된다 따라서 프로세스의 생성은 fork → exec 이 두가지 단계를 거친다고 할 수 있다 물론 저 두 단계는 독립적이어서 fork() 만 해서 부모를 복사하기만 할 수도 있다 Process Execution § 자식 프로세스가 생성되었을 때 부모가 취할 수 있는 동작은 두가지가 있는데 그냥 별개의 프로세스로써 자식이랑 같이 공존하며 실행되거나 자식 프로세스가 종료되어야 진행이 가능한 경우에는 block 을 먹어서 자식이 종료될때까지 기다릴 수도 있다 (wait() 시스템 콜) Process Termination § 프로세스가 자발적으로 종료될 때에는 일단 exit() 시스템 콜을 이용한다 프로그래밍 언어에서 지원하는 라이브러리(뭐 예를 들면 go 의 os 같은 거) 를 통해 exit() 시스템 콜을 호출할 수도 있고 아니면 프로그램 코드가 종료되면 (뭐 마지막 중괄호가 닫히는 등의 main() 함수가 리턴되는 시점) exit() 시스템 콜이 작동되도록 컴파일러가 넣어주는 등의 방법 등 여러가지의 방법이 있지만 어쨋든 자발적으로 프로세스가 종료될때는 exit() 시스템 콜이 무조건 호출된다 exit() 이 호출된 다음에는 자식이 부모에게 output data 를 보내게 되고 프로세스의 각종 자원들이 운영체제한테 반납된다 그럼 자발적이지 않은 경우는 무엇이냐 → 부모 프로세스가 자식의 수행을 종료시키는 경우가 존재한다 뭐 자식이 너무 많은 자원을 먹어서 한계치를 넘어선 경우랄지 자식이 하고 있는 작업이 불필요해진 경우랄지 부모가 종료된 경우랄지 운영체제는 (init process 가 아닌 이상) 부모가 없는 프로세스가 존재하도록 하지 않는다 따라서 부모가 종료될때는 자식을 전부 종료시킨 후에 종료되도록 하는데 자식한테 또 자식이 있을 경우에는 또 그 자식이 종료되는 절차를 밟을 거 아님 그래서 부모가 종료될때는 자식을도 단계적으로 종료되게 된다 Process Syscall § Fork § 이제 이건 fork() 시스템 콜에 대한 C 언어 코드 예제인데 일단 흔히 나올 수 있는 질문 중 하나는 부모 코드에 fork() 가 있는데 부모 코드를 그대로 복제하면 자식 코드에도 fork() 가 있을 것이고 그럼 자식도 fork() 를 해서 자식이 무한대로 생성되는거 아니냐 인데 아니다 앞서 fork() 를 할 때에는 Process context 전체를 복사한다고 했자네 따라서 PC 값도 복사가 되기 때문에 자식 프로세스는 프로그램의 맨 처음부터 실행하는 것이 아니라 fork() 가 호출된 바로 다음 시점부터 실행된다 그럼 PC 값이 복사된다면 부모와 자식은 같은 Physical memory address 의 instruction 을 실행하게 될까 그것도 아니다 왜냐면 PC 에 들어가는 값은 Virtual memory address 이기 때문에 PC 값이 같긴 하지만 실제로 참조하는 Address space 는 다르고 따라서 다른 Physical memory address 를 참조하게 된다 Physical memory address 에 대해서 CPU 는 알지 못한다 → CPU 가 사용하는 주소는 전부 Logical (뭐 Virtual address랑 거의 같다고 재철소장님이 그랬으니까) 이고 이걸 Physical address 로 바꾸는 건 CPU 가 아니라 Memory Management Module 이 BASE 랑 LIMIT 레지스터 값을 이용해 수행한다 참고 Difference between program counter in the executable and program counter in the main memory Does the program counter generate the virtual address or a physical address in a cpu? 부모와 자식이 코드가 동일하다면 어떻게 다른 작업을 하도록 할 수 있을 까? C 언어에 구현되어 있는 fork() 함수는 호출했을 때에 PID 값을 반환하도록 되어 있는데 생각해보면 호출된 이후에는 부모와 자식 이렇게 프로세스가 두개가 생기므로 fork() 함수는 각 프로세스에게 두번 PID 값을 반환한다고 생각할 수 있다 근데 이때 부모 프로세스에게는 양수 정수값을 반환하는 방식으로 생성된 자식 프로세스의 PID 값을 반환해주고 자식 프로세스에게는 0을 반환해준다 이걸 이용해서 하나의 코드로 부모와 자식에게 다른 일을 시킬 수 있다 Exec § exec() 시스템 콜은 위에서 말한 것처럼 새로운 프로그램으로 현재 프로세스를 덮어씌우는 것을 수행한다 그래서 C 언어에서는 이 시스템 콜을 위해 execlp() 라는 함수를 제공해주는데 뭐 문법은 위에 사진 보던가 너가 찾아봐라 3번째 인자부터 해당 프로그램의 Args 들이 들어가는데 마지막 인자는 null string 을 넣어서 닫아줘야 한다네 중요한건 exec() 시스템 콜을 호출하고 나면 새로운 프로그램이기 때문에 main() 함수의 맨 첫번째 줄부터 실행하게 된다 어찌보면 당연한 얘기지 → 프로그램이 새로 프로세스가 됐는데 당연히 Process context 는 없는게 맞지 다음은 exec() 을 실행하고 난 뒤에는 원래의 프로그램으로 되돌아오지는 못한다는 거다 이것도 당연한 얘기다 → 기존의 프로세스가 새로운 프로그램으로 덮어씌워졌으니까 원래꺼는 없어지고 되돌아오지도 못하는게 인지상정 마지막으로는 fork() 와 exec() 은 별개의 시스템 콜이기 때문에 fork() 없이도 exec() 을 호출하는게 가능하다는 거다 따라서 이때에는 자식이 생기는 방식이 아니라 그냥 나 자신이 새로 태어나게 된다 Wait § wait() 은 별거 없다 그냥 부모가 자식 끝날때까지 block 되어 기다리게 하는 시스템 콜이 wait() 이다 그래서 wait() 이 호출되면 커널은 해당 프로세스를 block 시켰다가 해당 프로세스의 자식 프로세스가 모두 종료되면 다시 ready 로 바꾼다 위 그림은 그냥 예제고 → 읽어보면 걍 별거 없다 wait() 을 이용한다고 할 수 있는 프로그램이 Shell 프로그램이다 결국에는 쉘의 경우에도 입력한 프로그램을 시키는 것이기 때문에 해당 프로그램을 자식 프로세스호 실행시키고 wait 하다가 끝나면 다시 커서를 깜빡이게 하는 방식으로 활용한다.</description>
    <pubDate>Tue, 31 Oct 2023 16:26:49 GMT</pubDate>
  </item><item>
    <title>5. CPU Scheduling</title>
    <link>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/5.-CPU-Scheduling</link>
    <guid>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/5.-CPU-Scheduling</guid>
    <description>CPU, IO Burst § (사진 사라짐) 프로세스가 실행되는 것은 (일반적으로) CPU 를 연속적으로 사용하다가 IO 때문에 Block 되있거나 하는 것의 반복이라고 할 수 있는데 이때 CPU 를 연속적을 사용하는 구간을 CPU Burst 라고 하고 IO 때문에 Block 먹어있는 구간을 IO Burst 라고 한다 CPU, IO Bound Job § (사진 사라짐) 이 그래프는 한 CPU Burst 의 실행시간과 CPU Burst 의 빈도를 나타낸 그래프인데 보면 왼쪽은 CPU Burst 의 기간이 아주 짧고 빠르게 반복된다 이것은 잦은 IO 에 의해 CPU Burst 와 IO Burst 가 빈번하게 반복되는경우인데 이러한 Job (== Process) 들을 IO Bound Job 이라고 한다 일반적으로 IO 는 표준 입출력 등의 사람과 Interaction 하기 위한 것이 많기 때문에 사람과의 interaction 이 잦은 경우에 IO Bound Job 이 된다 그리고 오른쪽의 Job 들은 한번 CPU 가 잡으면 오랫동안 사용하여 CPU Burst 의 기간이 길고 따라서 빈도는 낮아지는데 (당연히 한번 잡았을때 길게 쓰니까 빈도는 작아질 수 밖에 없다) 이러한 Job 들을 CPU Bound Job 이라고 부르고 일반적으로 연구 등의 목적을 위해 복잡한 계산을 오랫동안 진행하는 Job 들인 경우가 많다 뭐 그래서 IO Bound Job 이 사람과의 상호작용이 잦기 때문에 CPU Bound Job 이 너무 CPU 를 오래 잡고 있어 사용자 Response 가 늦어지는 일이 벌어지지 않게 하기 위해 CPU Scheduling 을 한다네 Scheduler, Dispatcher § CPU Scheduler: Ready 인 프로세스 중에 Running 상태가 될 프로세스를 고르는 커널 프로세스 CPU Scheduling 이 발생하는 경우는 대표적으로 다음과 같다 프로세스가 CPU Time 을 _자진 반납_하는 경우 (Non-preemptive) IO 등의 사유로 CPU Time 을 반납 (Running → Blocked) Process Terminate 로 CPU 반납 (Running → Exit) 프로세스가 CPU Time 을 빼앗기는 경우 (Preemptive) Timer interrupt (Running → Ready) IO 가 완료된 프로세스의 우선순위가 현재 프로세스보다 높을 때 (Blocked → Ready) Dispatcher: 현재의 프로세스에서 CPU Scheduler 가 고른 프로세스로 Context switch 를 진행하는 커널 프로세스 CPU Scheduling § 고려사항들 § Ready 상태인 (CPU Burst 에 진입한) 프로세스 중 누구한테 CPU 를 줄 것인가? 한번 CPU 를 받았으면 끝날때까지 계속 쓰게 할 것인가 아니면 중간에 뺏을 것인가? Performance Index (Measure, Criteria) § Performance Index 는 성능을 측정하는 척도를 의미하는데 아래와 같이 두개로 나눌 수 있다 System Performance: 얼마나 시스템의 자원을 효율적으로 굴리느냐 CPU Utilization: 얘는 CPU 이용률을 의미한다 “률” 이기 때문에 당연히 전체에서 부분이 차지하는 비율을 의미하는데 CPU Utilization 에서는 “시간” 을 기준으로 측정한다 → 즉, 시스템이 작동하고 있는 전체 시간 중에서 CPU 가 일을 하고 있는 비율이 얼마냐 Throughput: 얘는 처리량을 의미하는데 CPU Utilization 이 시간에 대한 값이었다면 얘는 양을 나타내는 값이다 즉, 단위시간동안 처리한 작업의 양을 의미하는 것 Program Performance: 사용자가 느끼는 프로세스의 빠릿빠릿함 Turnaround Time: 한번의 CPU Burst 동안 걸린 시간의 총합 Waiting Time: 한번의 CPU Burst 동안 CPU 가 할당되지 않고 기다린 시간의 총합 Response Time: 한번의 CPU Burst 동안 CPU 가 처음으로 할당되기까지 걸린 시간 그냥 이렇게만 보면 멍게소리인가 싶을텐데 한번의 CPU Burst 에 어떤 일들이 일어나는지를 생각해보면 알기 쉽다 먼저 IO Burst 가 끝나고 CPU Burst 에 들어온 시간이 0초라고 해보라 그러고 바로 CPU 를 할당받을 수 있으면 기모찌하겠지만 인생이란게 그렇게 녹록하지 않아서 4초에 CPU 를 할당받아서 작업을 했다라고 치면 첫 4초가 Response Time 이 되는 것 즉, CPU Burst 가 시작된 이래로 얼마나 빨리 CPU 가 할당되었느냐 이다 그리고 만일 Preemptive 로 스케줄링되어 6초에 CPU 를 빼앗겼다가 7초에 다시 받고 10초에 IO 가 생겨서 IO Burst 로 빠져나갔다고 치면 일단 기다린 시간을 다 합쳐보면 맨 처음 4초에 중간에 1초 기다렸으니까 5초 → 이게 Waiting Time 이 된다.</description>
    <pubDate>Tue, 31 Oct 2023 16:26:49 GMT</pubDate>
  </item><item>
    <title>6. Process Synchronize</title>
    <link>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/6.-Process-Synchronize</link>
    <guid>https://mdg.haeramk.im/os.fall.2022.ewha.ac.kr/6.-Process-Synchronize</guid>
    <description>Concurrency, Race Condition § (사진 사라짐) 일반적으로는 위 그림처럼 데이터를 저장하는 곳하고 연산하는 곳하고는 분리되어 있으며 연산하는 곳에서 데이터를 읽어들여 연산한 다음 저장하는 방식으로 작동되는데 (사진 사라짐) 위 그림처럼 동일한 데이터에 여러 연산이 접근하게 되면 문제가 생길 수 있다 이렇게 여러 연산이 하나의 데이터에 동시에 접근하는 문제를 Concurrency Problem, 동시성 문제 라 부르고 동시성 문제가 발생하게 되는 상황을 연산간 경쟁한다는 의미로 Race Condition 이라고 부르더라 이를 해결하기 위해서는 데이터의 접근 순서를 제어하는 로직이 필요하고 이런걸 Process Synchronization (프로세스 동기화) 라고 한다.</description>
    <pubDate>Tue, 31 Oct 2023 16:26:49 GMT</pubDate>
  </item>
    </channel>
  </rss>